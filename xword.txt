

21 Jul 19:41 2020 Makefile Page 1


  1	
  2	#/Users/moonpie/xword/Makefile Wed29Aug2018 {fcG}
  3	#/home/franx/xword/Makefile Sat31Jan2004 {fcG}
  4	
  5	CC = clang
  6	#######CC = gcc
  7	CFLAGS =  -g -O0 -DDEBUG=1 
  8	#######CFLAGS = -include version.h -Wall
  9	#######CFLAGS = -g3 -idirafter ../source -Wall -DDEBUG=1 
 10	
 11	OBJS = xw_buildpuzz.o xw_createlinks.o xw_error.o xw_html.o \
 12	xw_initpuzz.o xw_listutil.o xw_matchpuzz.o xw_printpuzz.o \
 13	xw_puzzutil.o xw_readsort.o xw_sizedict.o xw_tryword.o xw_fillpuzz.o \
 14	xword.o
 15	
 16	SOURCE = xword.c xw_buildpuzz.c xw_createlinks.c xw_error.c \
 17	xw_html.c xw_initpuzz.c xw_listutil.c xw_matchpuzz.c \
 18	xw_printpuzz.c xw_puzzutil.c xw_readsort.c xw_sizedict.c \
 19	xw_tryword.c xw_fillpuzz.c xwindex.c version.c
 20	
 21	xword: ${OBJS}
 22	        ${CC} ${CFLAGS} datecomp.c -o datecomp
 23	        ./datecomp ${CFLAGS} -c version.c -o version.o 
 24	        ${CC} ${CFLAGS} ${OBJS} version.o -o xword
 25	####### mv version2.h version1.h
 26	####### diff version1.h version2.h 
 27	####### rm -f version.o; sync
 28	
 29	datecomp: datecomp.c
 30	        ${CC} ${CFLAGS} datecomp.c -o datecomp
 31	
 32	testdate:
 33	        ./datecomp -E ${CFLAGS} version.c
 34	####### ./datecomp -E ${CFLAGS} -include version2.h version.c
 35	
 36	xwindex: xwindex.o xw_error.o
 37	        ${CC} ${CFLAGS} xwindex.o xw_error.o  -o xwindex
 38	
 39	xw_fillpuzz: xw_fillpuzz.o xw_error.o xw_sizedict.o  
 40	        ${CC} ${CFLAGS} xw_fillpuzz.o xw_error.o  xw_sizedict.o  -o xw_fillpuzz
 41	
 42	testindex: testindex.o xw_error.o
 43	        ${CC} ${CFLAGS} testindex.o xw_error.o -o testindex
 44	
 45	strip_punc: strip_punc.o
 46	        ${CC} ${CFLAGS} strip_punc.c -o strip_punc
 47	
 48	${OBJS} xwindex.o: ../source/defs.h xword.h


21 Jul 19:41 2020 Makefile Page 2


 49	
 50	bakup:
 51	        mcopy -t -o Makefile xw*.h xw*.c a:
 52	        mdir a:
 53	
 54	clean:
 55	        rm -f ${OBJS}
 56	
 57	git:
 58	        git add xword.h ${SOURCE} 
 59	print:
 60	        pr -f -e -n3 -l58 Makefile defs.h xword.h ${SOURCE} \
 61	> xword.txt
 62	
 63	######## End of /home/franx/Makefile ########


 6 Jul 20:27 2020 defs.h Page 1


  1	/* /home/franx/source/defs.h Thu29Jan2004 {fcG} */
  2	
  3	#ifndef _DEFS_H
  4	#define _DEFS_H 1
  5	#include        <stdio.h>
  6	
  7	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
  8	#               DEFINES                 #
  9	#                                       #
 10	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 11	
 12	#define EVER            ;;
 13	#define EQ              ==
 14	
 15	#define MAX(x,y)        ((x) > (y) ? (x) : (y))
 16	#define MIN(x,y)        ((x) < (y) ? (x) : (y))
 17	
 18	#define MAXINT          (~(int)(1<<(sizeof(int)*8-1)))
 19	#define MAXLONG         (~(1L<<(sizeof(long)*8-1)))
 20	#define MAXSHORT        (~(short)(1<<(sizeof(short)*8-1)))
 21	
 22	#define SZ_FILENAME     FILENAME_MAX
 23	#define SZ_STRING       100
 24	#define SZ_TABLE(x)     (sizeof(x)/sizeof(x[0]))
 25	
 26	#ifdef  __STDC__
 27	#define PR(fmt,value)   printf(#value " = %" #fmt "\t", (value))
 28	#define WHEN            printf("%s %s", __DATE__, __TIME__) 
 29	#define WHERE           printf("%s[%d]", __FILE__, __LINE__) 
 30	#else
 31	#define PR(fmt,value)   printf("value = %fmt\t", (value))
 32	#define WHEN
 33	#define WHERE
 34	#endif  /* __STDC__ */
 35	
 36	#define nL                      putchar('\n')
 37	#define PRINT1(f,x1)            PR(f,x1),nL
 38	#define PRINT2(f,x1,x2)         PR(f,x1),PRINT1(f,x2)
 39	#define PRINT3(f,x1,x2,x3)      PR(f,x1),PRINT2(f,x2,x3)
 40	#define PRINT4(f,x1,x2,x3,x4)   PR(f,x1),PRINT3(f,x2,x3,x4)
 41	
 42	#ifdef DEBUG
 43	#define TEST(x)         x
 44	#else
 45	#define TEST(x)
 46	#endif /* DEBUG */
 47	
 48	#ifdef extern


 6 Jul 20:27 2020 defs.h Page 2


 49	#define INIT(x)         =x
 50	#else
 51	#define INIT(x)
 52	#endif /* extern */
 53	
 54	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 55	#               TYPEDEFS                #
 56	#                                       #
 57	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 58	
 59	typedef enum bool { FALSE = 0, TRUE = 1 }       BOOLEAN;
 60	
 61	typedef unsigned char   UCHAR;
 62	typedef unsigned int    UINT;
 63	typedef unsigned long   ULONG;
 64	typedef unsigned short  USHORT;
 65	
 66	#endif /* _DEFS_H */
 67	
 68	/* End of /home/franx/defs.h */


18 Jul 20:16 2020 xword.h Page 1


  1	/* /home/franx/xword/xword.h Mon26Jan2004 {fcG} */
  2	
  3	// MODIFACTION HISTORY
  4	// When         Who     What
  5	// Sun18Jun2006 {fcG}   ph_checksum & ph_failpuzz added to PUZZHEAD
  6	// Tue17May2011 {fcG}   cd_word added to CLUEDESCIPTOR...
  7	// Sun12Jul2020 {fcG}   sed file added...
  8	// Sat18Jul2020 {fcG}   index file/dirs added
  9	
 10	#ifndef _XWORD_H
 11	#define _XWORD_H 1
 12	#include <ctype.h>
 13	#include <errno.h>
 14	#include <setjmp.h>
 15	#include <stdarg.h>
 16	#include <stdio.h>
 17	#include <stdlib.h>
 18	#include <string.h>
 19	#include <time.h>
 20	#include <unistd.h>
 21	#include "defs.h"
 22	
 23	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 24	#               DEFINES                 #
 25	#                                       #
 26	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 27	
 28	#define CLUELENGTH      200
 29	#define WORDLENGTH      20
 30	#define NUMLETTERS      26
 31	#define EOWORD          '$'
 32	#define NUMWORDS        100
 33	#define UNDEFINED       32767
 34	#define ORD(x)          ((x) - 'A')
 35	#define INV(x)          ((x) EQ ACROSS ? DOWN : ACROSS)
 36	#define DECODE(x)       ((x) EQ UNUSED ? "UNUSED"  : \
 37	                        (x) EQ ACROSS ? "ACROSS" : \
 38	                        (x) EQ DOWN ? "DOWN"       : \
 39	                        "???")
 40	#define INDEXDIR(x)     (sprintf(xw_indexdir,\
 41	                        "%s.index/%06d", xw_indexfile,(x)))
 42	
 43	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 44	#               TYPEDEFS                #
 45	#                                       #
 46	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 47	
 48	typedef enum severity { SV_INFO, SV_WARNING, SV_ERROR, SV_FATAL


18 Jul 20:16 2020 xword.h Page 2


 49	        } SEVERITY;
 50	
 51	typedef enum status { UNUSED = 0, ACROSS = 1, DOWN = 2
 52	        } STATUS;
 53	
 54	typedef struct  cluedescriptor
 55	{
 56	        char    *cd_clue;
 57	        char    *cd_word;
 58	        UINT    cd_number;
 59	}       CLUEDESCRIPTOR;
 60	
 61	typedef struct  puzzle
 62	{
 63	        char    pz_letter;
 64	        int     pz_rownum, pz_colnum;
 65	        struct  puzzle  *pz_up, *pz_down, *pz_left, *pz_right;
 66	        struct  wordlist *pz_ofaccrossword, *pz_ofdownword;
 67	}       PUZZLE;
 68	
 69	typedef struct  puzzhead
 70	{
 71	        struct puzzhead *ph_prevpuzz, *ph_failpuzz;
 72	        struct puzzle   *ph_puzzle;
 73	        struct wordlist *ph_lastword;
 74	        UINT            ph_numcols, ph_numrows,
 75	                        ph_numwords, ph_numletters;
 76	        float           ph_compact;
 77	        ULONG           ph_checksum;
 78	}       PUZZHEAD;
 79	
 80	typedef  struct wordfit
 81	{
 82	        int     wf_size, wf_x, wf_y;
 83	        STATUS  wf_status;
 84	}       WORDFIT;
 85	
 86	typedef struct  wordlist
 87	{
 88	        int wl_numchar;
 89	        char    wl_word[WORDLENGTH+1], wl_clue[CLUELENGTH+1];
 90	        STATUS  wl_status;
 91	        int     wl_xpos, wl_ypos;
 92	        struct  wordlist *wl_prev, *wl_next, *wl_sameletter[WORDLENGTH];
 93	        struct  puzzhead *wl_failpuzz;
 94	}       WORDLIST;
 95	
 96	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\


18 Jul 20:16 2020 xword.h Page 3


 97	#               EXTERNS                 #
 98	#                                       #
 99	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
100	
101	/*  extern      PUZZHEAD *header; */
102	extern  WORDFIT xw_best
103	#ifdef  extern
104	=
105	{
106	        0, 0, 0, UNUSED
107	};
108	#else
109	        ;
110	#endif
111	
112	extern  WORDFIT xw_ret
113	#ifdef  extern
114	=
115	{
116	        0, 0, 0, UNUSED
117	};
118	#else
119	
120	        ;
121	#endif
122	
123	extern  WORDLIST xw_start
124	#ifdef  extern
125	=
126	{
127	  WORDLENGTH+1, "", "", UNUSED, UNDEFINED, UNDEFINED, 0, 0, {NULL}
128	/* {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, */
129	/*  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL} */
130	};
131	#else
132	        ;
133	#endif
134	
135	extern  char    xw_inputfile[SZ_FILENAME+1],
136	                xw_outputfile[SZ_FILENAME+6],
137	                xw_indexfile[SZ_FILENAME+1],
138	                xw_indexdir[SZ_FILENAME+1],
139	                xw_sedfile[SZ_FILENAME+1];
140	extern  int     xw_puzz_compact_req, xw_totletters, xw_totwords;
141	extern  time_t  xw_starttime;
142	extern  jmp_buf xw_env;
143	
144	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\


18 Jul 20:16 2020 xword.h Page 4


145	#               FUNCTIONS               #
146	#                                       #
147	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
148	
149	int     main(int, char*[]);
150	
151	char    *date_compiled();
152	float   version();
153	
154	BOOLEAN xw_matchpuzz(PUZZHEAD *, PUZZHEAD *);
155	PUZZHEAD *xw_copypuzz(PUZZHEAD *);
156	PUZZHEAD *xw_fillpuzz(PUZZHEAD *);
157	PUZZHEAD *xw_initpuzz(WORDLIST *);
158	PUZZLE  *xw_pointpuzz(PUZZHEAD *, int, int);
159	void    xw_createcolumn(PUZZHEAD *, int);
160	void    xw_createlinks();
161	void    xw_createrow(PUZZHEAD *, int);
162	void    xw_error(SEVERITY, char *, ...);
163	void    xw_feeldown(PUZZHEAD *, WORDLIST *, int, PUZZLE *);
164	void    xw_feelleft(PUZZHEAD *, WORDLIST *, int, PUZZLE *);
165	void    xw_feelright(PUZZHEAD *, WORDLIST *, int, PUZZLE *);
166	void    xw_feelup(PUZZHEAD *, WORDLIST *, int, PUZZLE *);
167	void    xw_killlist();
168	void    xw_killpuzz(PUZZHEAD *);
169	void    *xw_malloc(size_t);
170	void    xw_printpuzz(PUZZHEAD *);
171	void    xw_pushlist(WORDLIST *);
172	void    xw_putwordin(PUZZHEAD *,WORDLIST *, STATUS, int, int);
173	int     xw_readsort();
174	void    xw_restartlist();
175	int     xw_sizedict(char *);
176	void    xw_tryword(PUZZHEAD *,WORDLIST *, int, WORDLIST *);
177	void    xw_html(PUZZHEAD *);
178	WORDLIST        *xw_buildpuzz(PUZZHEAD *, WORDLIST *);
179	WORDLIST        *xw_poplist();
180	
181	#endif /* _XWORD_H */
182	
183	/* End of /home/franx/xword/xword.h */


19 Jul 14:50 2020 xword.c Page 1


  1	/* /home/franx/xword/xword.c Mon26Jan2004 {fcG} */
  2	//
  3	//  Created by Frank Charles Gallacher on 22/5/20.
  4	//  Copyleft © 2020 Frank Charles Gallacher. All rights reserved.
  5	//
  6	// MODIFICATION HISTORY
  7	// When         Who     What
  8	// Wed08Jul2020 {fcG}   64-bit debug code.
  9	// Sun12Jul2020 {fcG}   "Thousand island" do-do bug squashed!!!
 10	
 11	#include <errno.h>
 12	#include <setjmp.h>
 13	#include <signal.h>
 14	#include <stdio.h>
 15	#include <stdlib.h>
 16	#include <string.h>
 17	#include <unistd.h>
 18	
 19	#include "defs.h"
 20	#define extern
 21	#include "xword.h"
 22	
 23	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 24	#       SIGINT_HANDLER                  #
 25	#                                       #
 26	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 27	
 28	static PUZZHEAD *sigint_puzzle_header=NULL;
 29	
 30	static void sigint_handler()
 31	{
 32	        printf(
 33	        "\033[7;31m<CTRL-C> received, Hanging up...\033[0m\n");
 34	        if (sigint_puzzle_header != NULL)
 35	        {
 36	                xw_printpuzz(sigint_puzzle_header);
 37	                xw_html(sigint_puzzle_header);
 38	        }
 39	        xw_error(SV_ERROR, "<CTRL-C> received, Hanging up...");
 40	}
 41	
 42	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 43	#               MAIN                    #
 44	#                                       #
 45	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 46	
 47	int main(int argc, char *argv[])
 48	{


19 Jul 14:50 2020 xword.c Page 2


 49	  if(setjmp(xw_env) EQ 0)
 50	    {
 51	      int count;
 52	      PUZZHEAD *puzzle_header, *old_puzzhead;
 53	      WORDLIST *failword, *word, *firstfail;
 54	      
 55	      printf(
 56	"\033[7m#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*#\033[0m\n");
 57	      printf(
 58	"\033[7m#  Welcome to Franx X-word Generator! #\033[0m\n");
 59	      printf(
 60	"\033[7m#             Version: %#4.2f           #\033[0m\n",
 61	        version());
 62	      printf(
 63	"\033[7m# Link Date: %s#\033[0m\n", date_compiled());
 64	      printf(
 65	"\033[7m#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*#\033[0m\n");
 66	/*      WHEN; */
 67	      if(argc < 2)
 68	        {
 69	          char buf[10];
 70	          
 71	          sprintf(buf, "%%%ds", SZ_FILENAME);
 72	          printf("\nInput file of words? ");
 73	          scanf(buf, xw_inputfile);
 74	          
 75	          sprintf(buf, "%%%ds", SZ_FILENAME);
 76	          printf("\nDictionary file of words? ");
 77	          scanf(buf, xw_indexfile);
 78	
 79	#ifdef SNARK
 80	          fprintf(stderr, "Output file for final puzzle?\n");
 81	          scanf(buf, xw_outputfile);
 82	          fprintf(stderr, "Puzzle compactness?\n");
 83	          scanf("%2d", &xw_puzz_compact_req);
 84	          TEST(PR(d, xw_puzz_compact_req));
 85	          TEST(PRINT2(s, xw_inputfile, xw_outputfile));
 86	#endif /* SNARK */
 87	 
 88	        }
 89	      else
 90	        {
 91	                PRINT1(s, argv[1]);
 92	                strncpy(xw_inputfile, argv[1], SZ_FILENAME);
 93	
 94	                if(argc EQ 3)
 95	                {
 96	                        PRINT1(s, argv[2]);


19 Jul 14:50 2020 xword.c Page 3


 97	                        strncpy(xw_indexfile, argv[2], SZ_FILENAME);
 98	                }
 99	                else
100	                {
101	                        strncpy(xw_indexfile, "", SZ_FILENAME);
102	                        
103	                }
104	        }
105	
106	time(&xw_starttime);
107	if ((count = xw_readsort()) > 0)
108	{
109	  xw_error(SV_ERROR,
110	"%d Errors encountered in parsing %s", count, xw_inputfile);
111	}
112	if (xw_totwords <= 1)
113	{
114	  xw_error(SV_FATAL,
115	"Don't be a Smartarse, a xword must have at least 2 words");
116	}
117	xw_createlinks();
118	
119	xw_poplist(); /* pop xw_start off wordlist?! */
120	
121	word = xw_poplist();
122	puzzle_header = xw_initpuzz(word);
123	TEST(PRINT1(#018lx, (ULONG)puzzle_header));
124	
125	#ifdef  SNARK
126	
127	GOBACK:
128	
129	do
130	{
131	        PUZZHEAD *temp;
132	
133	        temp = xw_copypuzz(puzzle_header);
134	        word = xw_poplist();
135	
136	        TEST(PRINT3(#018lx,
137	        (ULONG)word, (ULONG)temp, (ULONG)puzzle_header));
138	
139	        temp->ph_prevpuzz = puzzle_header;
140	        puzzle_header = temp;
141	}
142	while((word != NULL)
143	&& (failword = xw_buildpuzz(puzzle_header, word)) EQ NULL);
144	#endif  /* SNARK */


19 Jul 14:50 2020 xword.c Page 4


145	  
146	while((word = xw_poplist()))
147	{
148	        PUZZHEAD *temp;
149	
150	        temp = xw_copypuzz(puzzle_header);
151	        temp->ph_prevpuzz = puzzle_header;
152	        puzzle_header = temp;
153	        
154	        while(failword = xw_buildpuzz(puzzle_header, word))
155	        {
156	
157	                TEST(PRINT2(#018lx,
158	                (ULONG)failword, (ULONG)puzzle_header));
159	                puzzle_header->ph_failpuzz = failword->wl_failpuzz;
160	                failword->wl_failpuzz = puzzle_header;
161	                puzzle_header = puzzle_header->ph_prevpuzz;
162	                if(!puzzle_header)
163	                {
164	                        xw_error(SV_FATAL,
165	                        "Could not find spot for %s",
166	                        failword->wl_word);
167	                }
168	        }
169	}
170	        
171	#ifdef  SNARK
172	
173	
174	if (failword != NULL)
175	        {
176	          PUZZHEAD *temp;
177	              
178	          firstfail = failword;
179	          puzzle_header->ph_failpuzz = failword->wl_failpuzz;
180	          failword->wl_failpuzz = puzzle_header;
181	#ifdef DEBUG
182	                printf("\033[32;40m");
183	                PR(#018lx, (ULONG)firstfail);
184	                PR(s, firstfail->wl_word);
185	        printf("\033[0m\n");
186	#endif
187	          do
188	            {   
189	              do
190	                {
191	                  puzzle_header = puzzle_header->ph_prevpuzz;
192	                  if (puzzle_header EQ NULL)


19 Jul 14:50 2020 xword.c Page 5


193	                    {
194	                      puzzle_header = xw_initpuzz(failword);
195	                      break;
196	                    }
197	                  temp = xw_copypuzz(puzzle_header);
198	        #ifdef DEBUG
199	                  TEST(WHERE);
200	                  PRINT2(#018lx, (ULONG)temp,
201	                        (ULONG)puzzle_header);
202	                  xw_printpuzz(puzzle_header);
203	        #endif /* DEBUG */
204	                      
205	                  if(puzzle_header->ph_lastword != NULL)
206	                    {
207	                      xw_pushlist(puzzle_header->ph_lastword);
208	                    }
209	                  puzzle_header = temp;
210	                }
211	              while((word != NULL)
212	                && (xw_buildpuzz(puzzle_header,failword) != NULL));
213	
214	        #ifdef DEBUG
215	              printf("\033[32;40m");
216	              WHERE; printf("Found a spot for %s",
217	                        failword->wl_word);
218	              printf("\033[0m\n");
219	        #endif /* DEBUG */
220	              do
221	                {
222	                  temp = xw_copypuzz(puzzle_header); 
223	                  temp->ph_prevpuzz = puzzle_header;
224	                  puzzle_header = temp;
225	                  word = xw_poplist();
226	                }
227	              while((word != NULL)
228	                && (failword = xw_buildpuzz(puzzle_header,word)) EQ NULL);
229	              if (failword != NULL)
230	                {
231	                  old_puzzhead = failword->wl_failpuzz;
232	                  while(old_puzzhead != NULL)
233	                    {
234	                      if (xw_matchpuzz(old_puzzhead, puzzle_header))
235	                        
236	                        
237	                        xw_error(SV_FATAL, "Could not find spot for %s",
238	                        failword->wl_word);
239	                        }
240	                      old_puzzhead = old_puzzhead->ph_failpuzz;


19 Jul 14:50 2020 xword.c Page 6


241	                    }
242	                  if (failword EQ firstfail)
243	                    {
244	                      static WORDLIST *newhead = NULL;
245	        #ifdef DEBUG
246	                      PR(s, firstfail->wl_word);
247	                      PRINT2(#018lx, (ULONG)newhead, (ULONG)firstfail);
248	        #endif
249	                      if (newhead EQ NULL || firstfail != newhead)
250	                        {   
251	                          newhead = firstfail;
252	
253	                          xw_restartlist();
254	                          xw_poplist(); /* pop xw_start off wordlist?! */
255	
256	                          puzzle_header = xw_initpuzz(failword);
257	
258	        #ifdef DEBUG
259	                                printf("\033[32;40m");
260	                                WHERE; printf("Going to GOBACK...");
261	                                printf("\033[0m\n");
262	        #endif /* DEBUG */
263	                          goto GOBACK;
264	                        }
265	                    }
266	            }
267	            while((word != NULL) && (failword != NULL));
268	        }
269	
270	#endif  /* SNARK */
271	
272	        sigint_puzzle_header = puzzle_header;
273	        if (signal(SIGINT, (void (*)(int))sigint_handler) EQ SIG_ERR)
274	        {
275	                xw_error(SV_ERROR, "signal snarked!!!");
276	        }
277	
278	#ifdef  SNARK
279	for(EVER)
280	{
281	  ;
282	}
283	#endif  /* SNARK */
284	
285	        if (strncmp(xw_indexfile, "", SZ_FILENAME))
286	        {
287	                xw_fillpuzz(puzzle_header);
288	        }


19 Jul 14:50 2020 xword.c Page 7


289	        xw_html(puzzle_header);
290	        xw_killlist();
291	        exit(0);
292	}
293	else
294	        {
295	                fprintf(stderr, "xword: aborting due to errors...\n");
296	                exit(-1);
297	        }
298	}
299	/* End of /home/franx/xword/xword.c */


 8 Jul 23:39 2020 xw_buildpuzz.c Page 1


  1	/* /home/franx/xword/xw_buildpuzz.c Wed04Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Sun18Jun2006 {fcG}   ph_checksum aggregate added to
  6	//                      xw_putwordin().
  7	// Wed08Jul2020 {fcG}   64-bit debug code.
  8	
  9	#include <stdio.h>
 10	#include "xword.h"
 11	
 12	/* WORDFIT best = { UNDEFINED, 0, 0, UNUSED}; */
 13	/* WORDFIT ret  = { UNDEFINED, 0, 0, UNUSED}; */
 14	
 15	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 16	#               XW_BUILDPUZZ            #
 17	#                                       #
 18	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 19	
 20	WORDLIST *xw_buildpuzz(PUZZHEAD *ph, WORDLIST *word)
 21	{
 22	
 23	/*      register WORDLIST *word; */
 24	
 25	        register int i;
 26	        BOOLEAN  couldntbuild;
 27	/*      WORDLIST *failure; */
 28	
 29	        couldntbuild = FALSE;
 30	        if (word != NULL)
 31	          {
 32	            xw_best.wf_size = UNDEFINED;
 33	            xw_ret.wf_size = UNDEFINED;
 34	            for (i=0; i < word->wl_numchar; i++)
 35	              {
 36	                if(word->wl_sameletter[i] != NULL)
 37	                  {
 38	                    TEST(PRINT1(#018lx, (ULONG)word->wl_sameletter[i]));
 39	                    TEST(PRINT1(s, word->wl_sameletter[i]->wl_word));
 40	                    xw_tryword(ph, word, i, word->wl_sameletter[i]);
 41	                    if(xw_best.wf_size > xw_ret.wf_size)
 42	                        {
 43	                                xw_best.wf_size = xw_ret.wf_size;
 44	                                xw_best.wf_x = xw_ret.wf_x;
 45	                                xw_best.wf_y = xw_ret.wf_y;
 46	                                xw_best.wf_status = xw_ret.wf_status;
 47	                        }
 48	                  }


 8 Jul 23:39 2020 xw_buildpuzz.c Page 2


 49	              }
 50	#ifdef DEBUG
 51	            printf("xw_buildpuzz(): tryword returns ");
 52	            PRINT3(d, xw_best.wf_size, xw_best.wf_x, xw_best.wf_y);
 53	            printf("xw_best.wf_status = %d[%s]\n", xw_best.wf_status,
 54	                   DECODE(xw_best.wf_status));
 55	#endif /* DEBUG */
 56	            ph->ph_compact = (ph->ph_numrows - 2)
 57	                * (ph->ph_numcols - 2) + xw_best.wf_size;
 58	#if DEBUG
 59	              PRINT2(6f, (double)ph->ph_compact,
 60	                        (double)xw_puzz_compact_req);
 61	#endif /* DEBUG */
 62	            if(xw_best.wf_size EQ UNDEFINED)
 63	
 64	/*|| ((ph->ph_numrows - 2) * (ph->ph_numcols - 2) + xw_best.wf_size */
 65	/* > ((xw_totletters - 2) * (xw_totwords + 2)) * 100s
 66	 / xw_puzz_compact_req)) */
 67	
 68	              {
 69	                couldntbuild = TRUE;
 70	/*                  goto GETOUTOFHERE; */
 71	              }
 72	            else
 73	              {
 74	                xw_putwordin(ph, word, xw_best.wf_status,
 75	                        xw_best.wf_x, xw_best.wf_y);
 76	                xw_printpuzz(ph);
 77	          
 78	              }
 79	          }
 80	
 81	/*  GETOUTOFHERE: */
 82	
 83	/*      for(;index > 0; index--) */
 84	/*      { */
 85	/*        xw_pushlist(failure[index]); */
 86	/*      } */
 87	        if(couldntbuild)
 88	        {
 89	                xw_error(SV_INFO,
 90	                "xw_buildpuzz(): couldn't find a spot for %s",
 91	                word->wl_word);
 92	                return word;
 93	        }
 94	        else
 95	        {
 96	#ifdef DEBUG


 8 Jul 23:39 2020 xw_buildpuzz.c Page 3


 97	          printf("Success!!!\n");
 98	#endif /* DEBUG */
 99	          return NULL;
100	        }
101	}
102	
103	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
104	#               XW_PUTWORDIN            #
105	#                                       #
106	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
107	
108	void xw_putwordin(PUZZHEAD *p, WORDLIST *w, STATUS s, int x, int y)
109	{
110	        int i;
111	        PUZZLE  *ref;
112	
113	#ifdef  DEBUG
114	        printf("xw_putwordin: putting %s in at s = %d[%s], x = %d, y = %d\n",
115	                w->wl_word, s, DECODE(s), x, y);
116	#endif  /* DEBUG*/
117	
118	        if (s EQ ACROSS)
119	        {
120	                xw_createcolumn(p, x-1);
121	                xw_createcolumn(p, x+w->wl_numchar);
122	                ref = xw_pointpuzz(p, x-1, y);
123	                ref->pz_letter = EOWORD;
124	                ref = ref->pz_right;
125	                ref->pz_ofaccrossword = w;
126	        }
127	        else
128	        {
129	                xw_createrow(p, y-1);
130	                xw_createrow(p, y+w->wl_numchar);
131	                ref = xw_pointpuzz(p, x, y-1);
132	                ref->pz_letter = EOWORD;
133	                ref = ref->pz_down;
134	                ref->pz_ofdownword = w;
135	        }
136	        for (i=0; i<w->wl_numchar; i++)
137	        {
138	                if (ref->pz_letter EQ '\0')
139	                {
140	                  TEST(PR(c, w->wl_word[i]));
141	                  TEST(PRINT1(d, w->wl_word[i]));
142	                  p->ph_checksum += w->wl_word[i];
143	                }
144	                ref->pz_letter = w->wl_word[i];


 8 Jul 23:39 2020 xw_buildpuzz.c Page 4


145	                if (s EQ ACROSS)
146	                {
147	                        ref = ref->pz_right;
148	                }
149	                else
150	                {
151	                        ref = ref->pz_down;
152	                }
153	        }
154	        p->ph_numwords++;
155	        p->ph_lastword = w;
156	        ref->pz_letter = EOWORD;
157	        w->wl_status = s;
158	        w->wl_xpos = x;
159	        w->wl_ypos = y;
160	}
161	
162	/* End of /home/franx/xword/xw_buildpuzz.c */


 8 Jul 21:51 2020 xw_createlinks.c Page 1


  1	/* /home/franx/xword/xw_createlinks.c Mon02Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	/*  #include <stdio.h> */
  8	/*  #include <stdlib.h> */
  9	/*  #include <ctype.h> */
 10	/*  #include "defs.h" */
 11	#include "xword.h"
 12	
 13	WORDLIST        *letterlink[NUMLETTERS] =
 14	{
 15	        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 16	        NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
 17	        NULL, NULL, NULL, NULL, NULL, NULL
 18	};
 19	
 20	#ifdef SNARK
 21	int     *freqletters[NUMLETTERS];
 22	#endif /* SNARK */
 23	
 24	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 25	#               XW_CREATELINKS          #
 26	#                                       #
 27	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 28	
 29	/* This routine sets up rings to words that have the sameletter. */
 30	
 31	void xw_createlinks()
 32	{
 33	        register WORDLIST *ref, *prev = NULL;
 34	        register int i,j;
 35	
 36	        ref = xw_start.wl_next;
 37	        while(ref != NULL)
 38	        {
 39	          if (prev != NULL)
 40	          {
 41	            ref->wl_prev = prev;
 42	          }
 43	          prev = ref;
 44	
 45	          for(i = 0; i < ref->wl_numchar; i++)
 46	            {
 47	              j = ORD(ref->wl_word[i]);
 48	              ref->wl_sameletter[i] = letterlink[j];


 8 Jul 21:51 2020 xw_createlinks.c Page 2


 49	            }
 50	          for(i = 0; i < ref->wl_numchar; i++)
 51	            {
 52	              j = ORD(ref->wl_word[i]);
 53	              letterlink[j] = ref;
 54	            }
 55	          ref = ref->wl_next;
 56	        }
 57	
 58	        /*  Now link the head to the tail. */
 59	
 60	        ref = xw_start.wl_next;
 61	        while(ref != NULL)
 62	          {
 63	#ifdef DEBUG
 64	            printf("xw_createlinks: ref = %#018lx\n", (ULONG)ref);
 65	#endif /* DEBUG */
 66	
 67	            for(i = 0; i < ref->wl_numchar; i++)
 68	              {
 69	                j = ORD(ref->wl_word[i]);
 70	                if (ref->wl_sameletter[i] EQ NULL
 71	                    && ref != letterlink[j])
 72	                  {
 73	                    ref->wl_sameletter[i] = letterlink[j];
 74	#ifdef DEBUG
 75	                    printf(
 76	"xw_createlinks: %c evaluated to %2d, sameletter is %#018lx\n",
 77	ref->wl_word[i],j,(ULONG)ref->wl_sameletter[i]);
 78	
 79	#endif /* DEBUG */
 80	                  }
 81	              }
 82	            ref = ref->wl_next;
 83	          }
 84	
 85	        /*  Now check for words that do not have letters in other words. */
 86	
 87	        ref = xw_start.wl_next;
 88	        while(ref != NULL)
 89	          {
 90	            for(i = 0; i < ref->wl_numchar; i++)
 91	              {
 92	                if(ref->wl_sameletter[i] != NULL)
 93	                  {
 94	                    break;
 95	                  }
 96	                if(i EQ ref->wl_numchar - 1)


 8 Jul 21:51 2020 xw_createlinks.c Page 3


 97	                  {
 98	                    xw_error(SV_FATAL,"%s does not have letters in any other words",
 99	                             ref->wl_word);
100	                  }
101	              }
102	            ref = ref->wl_next;
103	          }
104	}
105	
106	/* End of /home/franx/xword/xw_createlinks.c */


 8 Jul 21:52 2020 xw_error.c Page 1


  1	/* /home/franx/xword/xw_error.c Sat31Jan2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	#include <stdarg.h>
  9	#include <stdlib.h>
 10	#include <errno.h>
 11	#include <setjmp.h>
 12	#include <string.h>
 13	
 14	#undef DEBUG
 15	
 16	#include "defs.h"
 17	#include "xword.h"
 18	
 19	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 20	#               XW_ERROR                #
 21	#                                       #
 22	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 23	
 24	void xw_error(SEVERITY sv, char *fmt, ...)
 25	{
 26	  va_list       ap;
 27	  
 28	  va_start(ap, fmt);
 29	  switch(sv)
 30	    {
 31	    case SV_FATAL:
 32	      fprintf(stderr,"\033[4;31mFATAL-");
 33	      break;
 34	    case SV_ERROR:
 35	      fprintf(stderr,"\033[31mERROR-");
 36	      break;
 37	    case SV_WARNING:
 38	      fprintf(stderr,"\033[35mWARN-");
 39	      break;
 40	    case SV_INFO:
 41	      fprintf(stderr,"\033[32mINFO-");
 42	    }
 43	  vfprintf(stderr, fmt, ap);
 44	  fprintf(stderr,"\033[0m\n");
 45	  va_end(ap);
 46	/*perror("xw_error()");  */
 47	  if (errno != 0)
 48	    {


 8 Jul 21:52 2020 xw_error.c Page 2


 49	      fprintf(stderr, "errno = %d (%s)\n", errno,
 50	              (char *)strerror(errno));
 51	    }
 52	  if (sv >= SV_ERROR)
 53	    {
 54	      longjmp(xw_env, -1);
 55	    }
 56	}
 57	
 58	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 59	#               XW_MALLOC               #
 60	#                                       #
 61	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 62	
 63	void *xw_malloc(size_t size)
 64	{
 65	  void *return_code;
 66	
 67	#ifdef SNARK
 68	  if ((return_code = malloc(size)) EQ NULL)
 69	#endif /* SNARK */
 70	    if ((return_code = calloc(1, size)) EQ NULL)
 71	      {
 72	        xw_error(SV_FATAL, "xw_malloc: OUT OF MEMORY!!!");
 73	      }
 74	
 75	#ifdef DEBUG
 76	  printf("xw_malloc(%d): ==> %#018lx\t", (UINT)size, (ULONG)return_code);
 77	#endif /* DEBUG */
 78	
 79	  return return_code;
 80	}
 81	
 82	/* End of /home/franx/xword/xw_error.c */
 83	
 84	
 85	


14 Jul 22:17 2020 xw_html.c Page 1


  1	/* /home/franx/xword/xw_html.c Mon24May2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Tue17May2011 {fcG}   Updated email address.
  6	// Sun12Jul2020 {fcG}   stderr => sed file.
  7	// Mon13Jul2020 {fcG}   sed I flag (fold case) not supported; removed.
  8	
  9	#include <stdio.h>
 10	#include <stdarg.h>
 11	#include <stdlib.h>
 12	#include <string.h>
 13	#include <errno.h>
 14	#include <setjmp.h>
 15	#include "defs.h"
 16	#include "xword.h"
 17	
 18	#define BORDER 0
 19	
 20	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 21	#               XW_HTML                 #
 22	#                                       #
 23	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 24	
 25	void xw_html(PUZZHEAD *puzz_hdr)
 26	{
 27	        FILE    *fp1, *fp2;
 28	        PUZZLE  *hptr, *vptr;
 29	        BOOLEAN new_word = FALSE;
 30	        register        UINT i=0, j=0, k=0, numword=0;
 31	        CLUEDESCRIPTOR  accrosslist[NUMWORDS], downlist[NUMWORDS];
 32	
 33	        strncpy(xw_sedfile, xw_inputfile, SZ_FILENAME);
 34	        strncat(xw_sedfile, ".sed", SZ_FILENAME);
 35	        printf("Writing sed Output to %s...\n", xw_sedfile);
 36	        if ((fp2 = fopen( xw_sedfile, "w")) EQ NULL)
 37	        {
 38	                xw_error(SV_ERROR, "Error opening \"%s\"", xw_sedfile);
 39	        }
 40	
 41	        strncpy(xw_outputfile, xw_inputfile, SZ_FILENAME);
 42	        strncat(xw_outputfile, ".html", SZ_FILENAME);
 43	        printf("Writing HTML Output to %s...\n", xw_outputfile);
 44	        if ((fp1 = freopen( xw_outputfile, "w", stdout)) EQ NULL)
 45	        {
 46	                xw_error(SV_ERROR, "Error opening \"%s\"", xw_outputfile);
 47	        }
 48	


14 Jul 22:17 2020 xw_html.c Page 2


 49	        printf(
 50	"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Final//EN\">\n");
 51	        printf("<!-- %s Version: %#4.2f Linked: %s{fcG} -->\n",
 52	                xw_outputfile, version(), date_compiled());
 53	        printf(
 54	"<!-- Copyleft © 2020 Frank Charles Gallacher. All rights reserved.-->\n");
 55	        printf("<HTML>\n");
 56	        printf("<HEAD>\n");
 57	        /* printf(
 58	"<LINK REL=\"StyleSheet\" TYPE=\"text/css\" HREF=\"xword_style.css\">\n"); */
 59	        printf("<LINK REV=\"made\" HREF=\"mailto:franxg@gmail.com\">\n");
 60	        printf("<META NAME=\"Author\" CONTENT=\"Frank C.Gallacher\">\n");
 61	        printf("<TITLE> Franx X-word Generator. </TITLE>\n");
 62	        printf("</HEAD>\n");
 63	
 64	        printf("<BODY BGCOLOR=\"White\">\n");
 65	
 66	        printf("<TABLE BORDER=\"%d\" BGCOLOR=\"Black\">", BORDER);
 67	
 68	        hptr = puzz_hdr->ph_puzzle;
 69	
 70	        if(puzz_hdr->ph_numwords != 1)
 71	        {
 72	                hptr = hptr->pz_down;
 73	        }
 74	        vptr = hptr->pz_right;
 75	        while(((hptr != NULL) && (puzz_hdr->ph_numwords EQ 1))
 76	        || ((hptr->pz_down != NULL) && (puzz_hdr->ph_numwords != 1)))
 77	        {
 78	          printf("<TR>\n");
 79	          while(vptr->pz_right != NULL)
 80	            {
 81	              new_word = FALSE;
 82	              if((vptr->pz_letter != '\0') && (vptr->pz_letter != EOWORD))
 83	                {
 84	                  if (vptr->pz_ofaccrossword != NULL)
 85	                    {
 86	                      accrosslist[j].cd_clue =
 87	                                vptr->pz_ofaccrossword->wl_clue;
 88	                        accrosslist[j].cd_word
 89	                                = vptr->pz_ofaccrossword->wl_word;
 90	                      accrosslist[j++].cd_number = ++numword;
 91	                      new_word = TRUE;
 92	                    }
 93	                  if (vptr->pz_ofdownword != NULL)
 94	                    {
 95	                      if (!new_word)
 96	                        {


14 Jul 22:17 2020 xw_html.c Page 3


 97	                          numword++;
 98	                        }
 99	                      downlist[k].cd_clue = vptr->pz_ofdownword->wl_clue;
100	                        downlist[k].cd_word = vptr->pz_ofdownword->wl_word;
101	                      downlist[k++].cd_number = numword;
102	                      new_word = TRUE;
103	                    }
104	                  
105	                  printf("<TD BGCOLOR=\"White\" ");
106	                  
107	                  printf(
108	                "<FONT COLOR=\"Black\" FACE=\"Courier\" SIZE=\"2\">");
109	                  if (new_word)
110	                    {
111	                      printf("%d<BR>&nbsp;&nbsp;&nbsp;&nbsp;", numword);
112	                    }
113	                  else
114	                    {
115	                      printf("&nbsp;&nbsp;&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;");
116	                    }
117	                  printf("</FONT>\n");
118	                  
119	                  
120	                  printf("</TD>");
121	                }
122	              else
123	                {
124	                  printf("<TD>");
125	                  printf("&nbsp;");
126	                  printf("</TD>");
127	                }
128	              vptr = vptr->pz_right;
129	            }
130	          printf("</TR>\n");
131	          hptr = hptr->pz_down;
132	          if (hptr != NULL)
133	            {
134	              vptr = hptr->pz_right;
135	            }
136	          else
137	            {
138	              break;
139	            }
140	        }
141	        printf("\n");
142	
143	        printf("</TABLE>\n");
144	


14 Jul 22:17 2020 xw_html.c Page 4


145	        printf("<TABLE BORDER=\"0\" BGCOLOR=\"White\">");
146	        printf("<TH> Across </TH>\n");
147	        printf("<TH> Down </TH>\n");
148	        
149	        for (i=0;i<MAX(j,k); i++)
150	        {
151	          printf("<TR>\n");
152	          
153	          if (i < j)
154	            {
155	              printf("<TD>%d.%s</TD>", accrosslist[i].cd_number, accrosslist[i].cd_clue);
156	                fprintf(fp2, "1,$s/%s/%dA/g\n", 
157	                        accrosslist[i].cd_word,
158	                        accrosslist[i].cd_number);
159	            }
160	          else
161	            {
162	              printf("<TD>&nbsp;</TD>\n");
163	            }
164	
165	          if (i < k)
166	            {
167	              printf("<TD>%d.%s</TD>",
168	                downlist[i].cd_number, downlist[i].cd_clue );
169	                fprintf(fp2, "1,$s/%s/%dD/g\n", 
170	                        downlist[i].cd_word,
171	                        downlist[i].cd_number);
172	            }
173	          else
174	            {
175	              printf("<TD>&nbsp;</TD>\n");
176	            }
177	          printf("</TR>\n");
178	        }
179	
180	                     
181	        printf("</TABLE>\n");
182	
183	        printf("<HR>\n");
184	
185	
186	        printf("<TABLE BORDER=\"%d\" BGCOLOR=\"Black\">", BORDER);
187	        hptr = puzz_hdr->ph_puzzle;
188	
189	        if(puzz_hdr->ph_numwords != 1)
190	        {
191	                hptr = hptr->pz_down;
192	        }


14 Jul 22:17 2020 xw_html.c Page 5


193	        vptr = hptr->pz_right;
194	        while(((hptr != NULL) && (puzz_hdr->ph_numwords EQ 1))
195	        || ((hptr->pz_down != NULL) && (puzz_hdr->ph_numwords != 1)))
196	        {
197	          printf("<TR>\n");
198	          while(vptr->pz_right != NULL)
199	            {
200	              if((vptr->pz_letter != '\0') && (vptr->pz_letter != EOWORD))
201	                {
202	                  printf("<TD BGCOLOR=\"White\" ");
203	                  
204	          printf("<FONT COLOR=\"Black\" FACE=\"Arial\" SIZE=\"2\">");
205	                  
206	                  printf("%c", vptr->pz_letter);
207	                  printf("</FONT>\n");
208	                  
209	                  
210	                  printf("</TD>");
211	                }
212	              else
213	                {
214	                  printf("<TD>");
215	                  printf("&nbsp;");
216	                  printf("</TD>");
217	                }
218	              vptr = vptr->pz_right;
219	            }
220	          printf("</TR>\n");
221	          hptr = hptr->pz_down;
222	          if (hptr != NULL)
223	            {
224	              vptr = hptr->pz_right;
225	            }
226	          else
227	            {
228	              break;
229	            }
230	        }
231	        printf("\n");
232	
233	        printf("</TABLE>\n");
234	
235	        printf("</BODY>\n");
236	        printf("</HTML>\n");
237	        fclose(fp1);
238	        fclose(fp2);
239	}
240	


14 Jul 22:17 2020 xw_html.c Page 6


241	/* End of /home/franx/xword/xw_html.c */


 8 Jul 21:53 2020 xw_initpuzz.c Page 1


  1	/* /home/franx/xword/xw_initpuzz.c Mon02Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	#include <stdlib.h>
  9	#include <ctype.h>
 10	#include <string.h>
 11	
 12	#undef DEBUG
 13	
 14	#include "defs.h"
 15	#include "xword.h"
 16	
 17	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 18	#               XW_INITPUZZ             #
 19	#                                       #
 20	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 21	
 22	PUZZHEAD *xw_initpuzz(WORDLIST *w)
 23	{
 24	
 25	        PUZZHEAD *puzzle_header;
 26	
 27	#if SNARK
 28	        register WORDLIST *w;
 29	#endif /* SNARK */
 30	
 31	        register PUZZLE *ref, *prev;
 32	        register int i;
 33	
 34	#ifdef DEBUG
 35	        printf("xw_initpuzz(): Starting up..\n");
 36	#endif /* DEBUG */
 37	
 38	        /* w = xw_poplist(); */
 39	        puzzle_header = (PUZZHEAD *)xw_malloc(sizeof(PUZZHEAD));
 40	
 41	#ifdef DEBUG
 42	        printf("initpuzz: xw_malloc returned %#018lx\n",
 43	               (ULONG)puzzle_header);
 44	#endif /* DEBUG */
 45	
 46	        puzzle_header->ph_numrows = 1;
 47	        puzzle_header->ph_numcols = w->wl_numchar+2;
 48	        puzzle_header->ph_numwords = 1;


 8 Jul 21:53 2020 xw_initpuzz.c Page 2


 49	        puzzle_header->ph_lastword = w;
 50	        puzzle_header->ph_prevpuzz = NULL;
 51	
 52	        ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 53	
 54	#ifdef DEBUG
 55	        printf("initpuzz: xw_malloc returned %#018lx\n", (ULONG)ref);
 56	#endif /* DEBUG */
 57	
 58	        puzzle_header->ph_puzzle = ref;
 59	        ref->pz_letter = EOWORD;
 60	        ref->pz_rownum = 0;
 61	        ref->pz_colnum = -1;
 62	        prev = ref;
 63	        ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 64	
 65	#ifdef DEBUG
 66	        printf("initpuzz: xw_malloc returned %#018lx\n", (ULONG)ref);
 67	#endif /* DEBUG */
 68	
 69	        ref->pz_ofaccrossword = w;
 70	        puzzle_header->ph_checksum = 0;
 71	        for(i = 0; i < w->wl_numchar; i++)
 72	        {
 73	                if (ref->pz_letter EQ '\0')
 74	                {
 75	                  TEST(PR(c, w->wl_word[i]));
 76	                  TEST(PRINT1(d, w->wl_word[i]));
 77	                  puzzle_header->ph_checksum += w->wl_word[i];
 78	                }
 79	                prev->pz_right = ref;
 80	                ref->pz_left = prev;
 81	                ref->pz_letter = w->wl_word[i];
 82	
 83	#ifdef DEBUG
 84	                TEST(PR(c, ref->pz_letter));
 85	#endif /* DEBUG */
 86	
 87	                ref->pz_rownum = 0;
 88	                ref->pz_colnum = i;
 89	                prev = ref;
 90	                ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 91	
 92	#ifdef DEBUG
 93	                printf("initpuzz: xw_malloc returned %#018lx\n",
 94	                        (ULONG)ref);
 95	#endif /* DEBUG */
 96	


 8 Jul 21:53 2020 xw_initpuzz.c Page 3


 97	        }
 98	        ref->pz_letter = EOWORD;
 99	        ref->pz_rownum = 0;
100	        ref->pz_colnum = w->wl_numchar;
101	        prev->pz_right = ref;
102	        ref->pz_left = prev;
103	        w->wl_status = ACROSS;
104	        w->wl_xpos = 0;
105	        w->wl_ypos = 0;
106	
107	        TEST(WHERE);
108	        TEST(PRINT1(#018lx, (ULONG)puzzle_header));
109	        return puzzle_header;
110	}
111	
112	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
113	#               XW_COPYPUZZ             #
114	#                                       #
115	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
116	
117	PUZZHEAD *xw_copypuzz(PUZZHEAD *old)
118	{
119	        PUZZHEAD *new;
120	        PUZZLE *hptr, *vptr, *prevcol, **prevrow;
121	        register int i,j;
122	
123	#ifdef DEBUG
124	        printf("xw_copypuzz(%#018lx): Starting up..\n", (ULONG)old);
125	#endif /* DEBUG */
126	
127	        new = (PUZZHEAD *)xw_malloc(sizeof(PUZZHEAD));
128	        memcpy(new, old, sizeof(PUZZHEAD));
129	        new->ph_lastword = NULL;
130	
131	        prevrow = (PUZZLE **)xw_malloc(old->ph_numcols * sizeof(PUZZLE *));
132	
133	        hptr = vptr = old->ph_puzzle;
134	        prevcol = NULL;
135	#ifdef DEBUG
136	        PRINT2(d, (UINT)old->ph_numrows,(UINT)old->ph_numcols);
137	#endif /* DEBUG */
138	        for(j=0; j < old->ph_numrows; j++)
139	          {
140	            for(i=0; i < old->ph_numcols; i++)
141	              {
142	                PUZZLE *temp;
143	                
144	                temp = (PUZZLE *)xw_malloc(sizeof(PUZZLE));


 8 Jul 21:53 2020 xw_initpuzz.c Page 4


145	
146	                memcpy(temp, vptr, sizeof(PUZZLE));
147	
148	                if (i EQ 0)
149	                  {
150	                    if (j EQ 0)
151	                      {
152	                        new->ph_puzzle = temp;
153	                      }
154	                  }
155	                else
156	                  {
157	                    temp->pz_left = prevcol;
158	                    prevcol->pz_right = temp;
159	                  }
160	                if (j != 0)
161	                  {
162	                    temp->pz_up = prevrow[i];
163	                    prevrow[i]->pz_down = temp;
164	                  }
165	#ifdef DEBUG
166	                PRINT2(d, (UINT)i, (UINT)j);
167	                PRINT3(#018x, (ULONG)prevrow[i], (ULONG)prevcol,
168	                       (ULONG)temp);
169	#endif /* DEBUG */
170	                vptr = vptr->pz_right;
171	                prevrow[i] = prevcol = temp;
172	
173	              }
174	
175	            hptr = vptr = hptr->pz_down;
176	        }
177	        free(prevrow);
178	        return new;
179	}
180	
181	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
182	#               XW_KILLPUZZ             #
183	#                                       #
184	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
185	
186	void xw_killpuzz(PUZZHEAD *puzzle_header)
187	{
188	        PUZZLE *hptr, *vptr, *temp;
189	
190	
191	#ifdef DEBUG
192	        printf("xw_killpuzz(%#018lx): Starting up..\n",


 8 Jul 21:53 2020 xw_initpuzz.c Page 5


193	                (ULONG)puzzle_header);
194	#endif /* DEBUG */
195	
196	        hptr = puzzle_header->ph_puzzle;
197	        while (hptr != NULL)
198	        {
199	                vptr = hptr;
200	                hptr = hptr->pz_down;
201	                while(vptr != NULL)
202	                {
203	                        temp = vptr;
204	                        vptr = vptr->pz_right;
205	                        free(temp);
206	                }
207	        }
208	        free(puzzle_header);
209	}
210	
211	/* End of /home/franx/xword/xw_initpuzz.c */
212	
213	
214	


10 Jul 00:17 2020 xw_listutil.c Page 1


  1	/* /home/franx/xword/xw_listutil.c Mon02Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	#include "defs.h"
  9	#include "xword.h"
 10	
 11	static WORDLIST *nextword = &xw_start;
 12	
 13	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 14	#               XW_POPLIST              #
 15	#                                       #
 16	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 17	
 18	WORDLIST *xw_poplist()
 19	{
 20	    TEST(PRINT1(#018lx, (ULONG)nextword));
 21	    if(nextword != NULL)
 22	      {
 23	        WORDLIST *temp;
 24	        
 25	        while (nextword != NULL && nextword->wl_status != UNUSED)
 26	          {
 27	            nextword = nextword->wl_next;
 28	          }
 29	        if (nextword != NULL)
 30	          {
 31	#ifdef DEBUG
 32	            printf("poplist: returned %#018lx which points to %s\n",
 33	                   (ULONG)nextword, nextword->wl_word);
 34	#endif /* DEBUG */
 35	            temp = nextword;
 36	            nextword = nextword->wl_next;
 37	            return temp;
 38	          }
 39	        else
 40	          {
 41	            return NULL;
 42	          }
 43	      }
 44	    else
 45	      {
 46	/*            xw_error(SV_ERROR,"poplist: The list is exhausted"); */
 47	        return NULL;
 48	      }


10 Jul 00:17 2020 xw_listutil.c Page 2


 49	}
 50	
 51	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 52	#               XW_PUSHLIST             #
 53	#                                       #
 54	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 55	
 56	void xw_pushlist(struct wordlist *ref)
 57	{
 58	          register WORDLIST *cur, *ptr;
 59	
 60	          cur = nextword;
 61	
 62	#ifdef DEBUG
 63	          printf("pushlist: putting %#018lx which points to %s back on\n",
 64	                  (ULONG)ref, ref->wl_word);
 65	          ptr = xw_start.wl_next;
 66	          while (ptr != NULL)
 67	            {
 68	              printf("%#018lx\t[%s]\t%s\n", (ULONG)ptr, ptr->wl_word,
 69	                DECODE(ptr->wl_status));
 70	              ptr = ptr->wl_next;
 71	            }
 72	#endif /* DEBUG */
 73	 
 74	          ref->wl_status = UNUSED;
 75	          ref->wl_xpos = ref->wl_ypos = 0;
 76	
 77	          if (cur EQ NULL)
 78	            {
 79	              nextword = ref;
 80	            }
 81	          else
 82	            {
 83	              while(cur != ref && cur != NULL)
 84	                {
 85	  /* PRINT3(#018lx, (ULONG)cur, (ULONG)cur->wl_next, (ULONG)nextword); */
 86	  /* PRINT1(#018lx, (ULONG)cur->wl_prev); */
 87	                  
 88	                  cur = cur->wl_prev;
 89	#ifdef DEBUG
 90	                  printf("pushlist: cur = %#018lx\t\n", (ULONG)cur);
 91	#endif /* DEBUG */
 92	                  if(cur EQ NULL)
 93	                    {
 94	/*                    xw_error(SV_ERROR, */
 95	/*                     "pushlist: %#018lx [%s] was not in wordlist", */
 96	/*                     (ULONG)ref, ref->wl_word); */


10 Jul 00:17 2020 xw_listutil.c Page 3


 97	
 98	                      break;
 99	                    }
100	                }
101	              if (cur != NULL)
102	                {
103	                  nextword = cur;
104	                }
105	            }
106	
107	          TEST(PRINT1(#018lx, (ULONG)nextword));
108	
109	          /* ref->wl_next = nextword; */
110	          /* cur->wl_next = nextword = ref; */
111	
112	}
113	
114	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
115	#               XW_RESTARTLIST          #
116	#                                       #
117	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
118	
119	void xw_restartlist()
120	{
121	
122	/*  This resets the list. */
123	          WORDLIST *ref;
124	
125	#ifdef DEBUG
126	          printf("xw_restartlist(): Starting up..\n");
127	#endif
128	
129	          nextword = &xw_start;
130	          ref = nextword->wl_next;
131	          while (ref != NULL)
132	            {
133	
134	#ifdef DEBUG
135	                printf("xw_restartlist(): ref = %#018lx[%s]\n",
136	                (ULONG)ref, ref->wl_word);
137	#endif
138	
139	              ref->wl_status = UNUSED;
140	              ref = ref ->wl_next;
141	            }
142	}
143	
144	/* End of /home/franx/xword/xw_listutil.c */


 8 Jul 21:54 2020 xw_matchpuzz.c Page 1


  1	/* /home/franx/xw_matchpuzz.c Wed21Jun2006 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	/* #define extern */
  9	#include "xword.h"
 10	
 11	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 12	#               xwmatchpuzz()           #
 13	#returns TRUE if both puzzles identical #
 14	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 15	
 16	BOOLEAN xw_matchpuzz(PUZZHEAD *puzz1, PUZZHEAD *puzz2)
 17	{
 18	    PUZZLE *h1ptr, *h2ptr, *v1ptr, *v2ptr;
 19	#ifdef  DEBUG
 20	    ULONG checksum = 0;
 21	
 22	    WHERE, WHEN;;
 23	    printf(" xw_matchpuzz()::");
 24	    PRINT2(#018lx, (ULONG)puzz1, (ULONG)puzz2);
 25	    PRINT2(d, (UINT)puzz1->ph_checksum, (UINT)puzz2->ph_checksum);
 26	#endif  /* DEBUG */
 27	    if((puzz1->ph_numrows != puzz2->ph_numrows)
 28	       || (puzz1->ph_numcols != puzz2->ph_numcols)
 29	       || (puzz1->ph_checksum != puzz2->ph_checksum))
 30	      {
 31	        return FALSE;
 32	      }
 33	    h1ptr = puzz1->ph_puzzle;
 34	    h2ptr = puzz2->ph_puzzle;
 35	    if (puzz1->ph_numwords != 1)
 36	      {
 37	        h1ptr = h1ptr->pz_down;
 38	      }
 39	    if (puzz2->ph_numwords != 1)
 40	      {
 41	        h2ptr = h2ptr->pz_down;
 42	      }
 43	    while(h1ptr != NULL)
 44	      {
 45	        v1ptr = h1ptr->pz_right;
 46	        v2ptr = h2ptr->pz_right;
 47	        while(v1ptr != NULL)
 48	          {


 8 Jul 21:54 2020 xw_matchpuzz.c Page 2


 49	            if (v1ptr->pz_letter != v2ptr->pz_letter)
 50	              {
 51	                return FALSE;
 52	              }
 53	#ifdef  DEBUG
 54	            if ((v1ptr->pz_letter != EOWORD)
 55	                && (v1ptr->pz_letter != '\0'))
 56	              {
 57	                TEST(PR(c, v1ptr->pz_letter));
 58	                TEST(PRINT1(d, v1ptr->pz_letter));
 59	                checksum += v1ptr->pz_letter;
 60	              }
 61	#endif  /* DEBUG */
 62	
 63	            v1ptr = v1ptr->pz_right;
 64	            v2ptr = v2ptr->pz_right;
 65	          }
 66	        h1ptr = h1ptr->pz_down;
 67	        h2ptr = h2ptr->pz_down;
 68	      }
 69	    TEST(PRINT1(d, (UINT)checksum));
 70	    return TRUE;
 71	}
 72	
 73	#ifdef  SNARK
 74	
 75	WORDLIST word1 = { 8, "ELEPHANT", "", UNUSED, UNDEFINED, UNDEFINED, 0, 0, NULL };
 76	WORDLIST word2 = { 8, "ANTEATER", "", UNUSED, UNDEFINED, UNDEFINED, 0, 0, NULL };
 77	WORDLIST word3 = { 3, "PIG", "", UNUSED, UNDEFINED, UNDEFINED, 0, 0, NULL };
 78	
 79	int main(int argc, char *argv[])
 80	{
 81	  PUZZHEAD *ph1, *ph2;
 82	
 83	  ph1 = xw_initpuzz(&word1);
 84	  ph2 = xw_initpuzz(&word1);
 85	  xw_putwordin(ph1, &word2, DOWN, 5, 0);
 86	  xw_putwordin(ph2, &word2, DOWN, 5, 0);
 87	  xw_printpuzz(ph1);
 88	  xw_printpuzz(ph2);
 89	  if (xw_matchpuzz(ph1, ph2))
 90	    {
 91	      printf("xw_matchpuzz() returns TRUE\n");
 92	    }
 93	  else
 94	    {
 95	      printf("xw_matchpuzz() returns FALSE\n");
 96	    } 


 8 Jul 21:54 2020 xw_matchpuzz.c Page 3


 97	  xw_putwordin(ph1, &word3, DOWN, 3, 0);
 98	  xw_printpuzz(ph1);
 99	  xw_printpuzz(ph2);
100	  if (xw_matchpuzz(ph1, ph2))
101	    {
102	      printf("xw_matchpuzz() returns TRUE\n");
103	    }
104	  else
105	    {
106	      printf("xw_matchpuzz() returns FALSE\n");
107	    } 
108	}
109	
110	#endif  /* SNARK */
111	
112	/* End of /home/franx/xw_matchpuzz.c  */


 8 Jul 22:47 2020 xw_printpuzz.c Page 1


  1	/* /home/franx/xword/xw_printpuzz.c Tue03Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	#include <stdarg.h>
  9	#include <stdlib.h>
 10	#include <errno.h>
 11	#include <setjmp.h>
 12	#include "defs.h"
 13	#include "xword.h"
 14	
 15	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 16	#               XW_PRINTPUZZ            #
 17	#                                       #
 18	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 19	
 20	void xw_printpuzz(PUZZHEAD *puzz_hdr)
 21	{
 22	          PUZZLE        *hptr, *vptr;
 23	          register      int i;
 24	
 25	#ifndef DEBUG
 26	          printf("\033[2J\033[0;0H");
 27	#else
 28	          printf("xw_printpuzz(%#018lx)\n", (ULONG)puzz_hdr);
 29	#endif  /*  DEBUG */
 30	
 31	          TEST(WHEN;nL);
 32	          puzz_hdr->ph_numletters = 0;
 33	          hptr = puzz_hdr->ph_puzzle;
 34	
 35	          if(puzz_hdr->ph_numwords != 1)
 36	            {
 37	              hptr = hptr->pz_down;
 38	            }
 39	          vptr = hptr->pz_right;
 40	#ifdef DEBUG
 41	          printf("   ");
 42	          while(vptr != NULL)
 43	            {
 44	              printf("%2d", vptr->pz_colnum);
 45	              vptr = vptr->pz_right;
 46	            }
 47	          vptr = hptr->pz_right;
 48	          printf("\n    ");


 8 Jul 22:47 2020 xw_printpuzz.c Page 2


 49	#endif /* DEBUG */
 50	          printf("+");
 51	           for(i = 0; i < puzz_hdr->ph_numcols - 2; i++)
 52	            {
 53	              printf("-+");
 54	            }
 55	          printf("\n");
 56	
 57	          while(((hptr != NULL) && (puzz_hdr->ph_numwords EQ 1))
 58	                || ((hptr->pz_down != NULL) && (puzz_hdr->ph_numwords != 1)))
 59	            {
 60	#ifdef DEBUG
 61	
 62	/*            PRINT2(#018lx, (ULONG)hptr, (ULONG)vptr); */
 63	
 64	              printf("%4d", hptr->pz_rownum);
 65	#endif /* DEBUG */
 66	              printf("|");
 67	
 68	              while(vptr->pz_right != NULL)
 69	                {
 70	#ifdef DEBUG
 71	                  if(vptr->pz_letter == EOWORD)
 72	                    {
 73	                      printf("%c|", EOWORD);
 74	                    }
 75	                  else
 76	#endif /* DEBUG */
 77	                    if((vptr->pz_letter != '\0') && (vptr->pz_letter != EOWORD))
 78	                      {
 79	                        puzz_hdr->ph_numletters++;
 80	#ifdef DEBUG
 81	                        printf("%c|", vptr->pz_letter);
 82	#else
 83	                        printf("\033[0;4m%c|\033[0m", vptr->pz_letter);
 84	#endif /* DEBUG */
 85	                      }
 86	                    else
 87	                      {
 88	#if DEBUG
 89	                        printf(" |");
 90	#else
 91	                        printf("\033[40m  \033[0m");
 92	#endif /* DEBUG */
 93	                      }
 94	                  vptr = vptr->pz_right;
 95	                }
 96	              printf("\n");


 8 Jul 22:47 2020 xw_printpuzz.c Page 3


 97	              hptr = hptr->pz_down;
 98	              if (hptr != NULL)
 99	                {
100	                  vptr = hptr->pz_right;
101	                }
102	              else
103	                {
104	                  break;
105	                }
106	            }
107	          TEST(PRINT1(d, puzz_hdr->ph_numcols));
108	#ifdef DEBUG
109	          printf("  ");
110	#endif /* DEBUG */
111	          printf("+");
112	          for(i = 0; i < puzz_hdr->ph_numcols - 2; i++)
113	            {
114	              printf("-+");
115	            }
116	          printf("\n");
117	
118	          if (puzz_hdr->ph_numwords != 1)
119	            {
120	                puzz_hdr->ph_compact = puzz_hdr->ph_numletters
121	                /(((float)puzz_hdr->ph_numrows-2.0)
122	                * ((float)puzz_hdr->ph_numcols - 2.0)) * 100.0;
123	                printf("Puzzle Compactness: %6.2f%%\n",
124	                puzz_hdr->ph_compact);
125	            }
126	          printf("Time taken to insert %d words: %6.2f secs.\n",
127	                 puzz_hdr->ph_numwords, difftime(time(NULL), xw_starttime));
128	#if DEBUG
129	          PR(s, puzz_hdr->ph_lastword->wl_word);
130	          PRINT2(#018lx, (ULONG)puzz_hdr->ph_lastword, (ULONG)puzz_hdr->ph_prevpuzz);
131	#endif /* DEBUG */
132	
133	}
134	
135	/* End of /home/franx/xword/xw_printpuzz.c */


 8 Jul 21:55 2020 xw_puzzutil.c Page 1


  1	/* /home/franx/xword/xw_puzzutil.c Tue10Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include "xword.h"
  8	
  9	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 10	#               XW_CREATEROW            #
 11	#                                       #
 12	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 13	
 14	void    xw_createrow(PUZZHEAD *ph, int i)
 15	{
 16	        register        int j,k;
 17	        register        PUZZLE *ref, *prev, *prevrow, *edge;
 18	
 19	#if DEBUG
 20	        printf("xw_createrow: i = %d\n", i);
 21	#endif /* DEBUG */
 22	
 23	        if(i < ph->ph_puzzle->pz_rownum)
 24	          {
 25	            prevrow = ph->ph_puzzle;
 26	            for(j = ph->ph_puzzle->pz_rownum - 1; j >= i; j--)
 27	              {
 28	                ph->ph_numrows++;
 29	                edge = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 30	                ref = edge;
 31	                prev = NULL;
 32	                for (k = 0; k < ph->ph_numcols; k++)
 33	                  {
 34	                    ref->pz_letter = '\0';
 35	                    ref->pz_rownum = j;
 36	                    ref->pz_colnum = prevrow->pz_colnum;
 37	                    ref->pz_left = prev;
 38	                    if(prev != NULL)
 39	                      {
 40	                        prev->pz_right = ref;
 41	                      }
 42	                    ref->pz_down = prevrow;
 43	                    prevrow->pz_up = ref;
 44	                    prev = ref;
 45	                    ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 46	                    prevrow = prevrow->pz_right;
 47	                  }
 48	                prevrow = edge;


 8 Jul 21:55 2020 xw_puzzutil.c Page 2


 49	              }
 50	            ph->ph_puzzle = edge;
 51	          }
 52	        else
 53	          {
 54	            prevrow = ph->ph_puzzle;
 55	            while(prevrow->pz_down != NULL)
 56	              {
 57	                prevrow = prevrow->pz_down;
 58	              }
 59	            if (prevrow->pz_down != NULL)
 60	              {
 61	                prevrow = prevrow->pz_down;
 62	              }
 63	            if (prevrow->pz_rownum < i)
 64	              {
 65	                for (j = prevrow->pz_rownum + 1; j <= i; j++)
 66	                  {
 67	                    ph->ph_numrows++;
 68	                    edge = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 69	                    ref = edge;
 70	                    prev = NULL;
 71	                    for (k = 0; k < ph->ph_numcols; k++)
 72	                      {
 73	                        ref->pz_letter = '\0';
 74	                        ref->pz_rownum = j;
 75	                        ref->pz_colnum = prevrow->pz_colnum;
 76	                        ref->pz_left = prev;
 77	                        if(prev != NULL)
 78	                          {
 79	                            prev->pz_right = ref;
 80	                          }
 81	                        ref->pz_up = prevrow;
 82	                        prevrow->pz_down = ref;
 83	                        prev = ref;
 84	                        ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
 85	                        prevrow = prevrow->pz_right;
 86	                      }
 87	                    prevrow = edge;
 88	                  }
 89	              }
 90	          }
 91	}
 92	
 93	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 94	#               XW_CREATECOLUMN         #
 95	#                                       #
 96	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/


 8 Jul 21:55 2020 xw_puzzutil.c Page 3


 97	
 98	void    xw_createcolumn(PUZZHEAD *ph, int i)
 99	{
100	        register        int j, k;
101	        register        PUZZLE *ref, *prev, *prevcol, *edge;
102	
103	#if DEBUG
104	        printf("xw_createcolumn: i = %d\n", i);
105	        PRINT1(d, ph->ph_puzzle->pz_colnum);
106	#endif /* DEBUG */
107	
108	        if(i < ph->ph_puzzle->pz_colnum)
109	          {
110	            prevcol = ph->ph_puzzle;
111	            for(j = ph->ph_puzzle->pz_colnum - 1; j >= i; j--)
112	              {
113	                ph->ph_numcols++;
114	                edge = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
115	                ref = edge;
116	                prev = NULL;
117	                for (k = 0; k < ph->ph_numrows; k++)
118	                  {
119	                    ref->pz_letter = '\0';
120	                    ref->pz_colnum = j;
121	#ifdef DEBUG
122	                    PR(#018lx, (ULONG)prevcol);
123	                    PRINT2(d, (UINT)prevcol->pz_rownum,
124	                           (UINT)ph->ph_numcols);
125	#endif /* DEBUG */
126	                    ref->pz_rownum = prevcol->pz_rownum;
127	                    ref->pz_up = prev;
128	                    if(prev != NULL)
129	                      {
130	                        prev->pz_down = ref;
131	                      }
132	                    ref->pz_right = prevcol;
133	                    prevcol->pz_left = ref;
134	                    prev = ref;
135	                    ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
136	                    prevcol = prevcol->pz_down;
137	                  }
138	                prevcol = edge;
139	              }
140	            ph->ph_puzzle = edge;
141	          }
142	        else
143	          {
144	            prevcol = ph->ph_puzzle;


 8 Jul 21:55 2020 xw_puzzutil.c Page 4


145	            while(prevcol->pz_right != NULL)
146	              {
147	                prevcol = prevcol->pz_right;
148	              }
149	            if (prevcol->pz_colnum < i)
150	              {
151	                for (j = prevcol->pz_colnum + 1; j <= i; j++)
152	                  {
153	                    ph->ph_numcols++;
154	                    edge = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
155	                    prev = NULL;
156	                    ref = edge;
157	                    for (k = 0; k < ph->ph_numrows; k++)
158	                      {
159	                        ref->pz_letter = '\0';
160	                        ref->pz_colnum = j;
161	                        ref->pz_rownum = prevcol->pz_rownum;
162	                        ref->pz_up = prev;
163	                        if(prev != NULL)
164	                          {
165	                            prev->pz_down = ref;
166	                          }
167	                        ref->pz_left = prevcol;
168	                        prevcol->pz_right = ref;
169	                        prev = ref;
170	                        ref = (PUZZLE *)xw_malloc(sizeof(PUZZLE));
171	                        prevcol = prevcol->pz_down;
172	                      }
173	                    prevcol = edge;
174	                  }
175	              }
176	          }
177	}
178	
179	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
180	#               XW_POINTPUZZ            #
181	#                                       #
182	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
183	
184	PUZZLE  *xw_pointpuzz(PUZZHEAD *ph, int x, int y)
185	{
186	  register PUZZLE *ref;
187	
188	#if DEBUG
189	        printf("xw_pointpuzz: x = %d, y = %d\n", (int)x, (int)y);
190	        WHERE, PRINT1(#018lx, (ULONG)ph);
191	/*      PRINT2(d, ph->ph_puzzle->pz_rownum, ph->ph_puzzle->pz_colnum); */
192	#endif /* DEBUG */


 8 Jul 21:55 2020 xw_puzzutil.c Page 5


193	        ref = ph->ph_puzzle;
194	        if((ref->pz_colnum > x) || (ref->pz_rownum > y))
195	        {
196	          xw_error(SV_INFO, "pointpuzz: setting ref to NULL");
197	          ref = NULL;
198	        }
199	        else
200	        {
201	          while((ref != NULL) && (ref->pz_colnum < x))
202	            {
203	              ref = ref->pz_right;
204	            }
205	          while ((ref != NULL) && (ref->pz_rownum < y))
206	            {
207	              ref = ref->pz_down;
208	            }
209	        }
210	#if DEBUG
211	          printf("xw_pointpuzz: returning %#018lx\n", (ULONG)ref);
212	#endif /* DEBUG */
213	          return ref;
214	}
215	
216	/* End of /home/franx/xword/xw_puzzutil.c */


 8 Jul 22:52 2020 xw_readsort.c Page 1


  1	/* /home/franx/xword/xw_readsort.c Mon02Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	#include <stdlib.h>
  9	#include <ctype.h>
 10	#include "defs.h"
 11	#include "xword.h"
 12	
 13	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 14	#               READSORT                #
 15	#                                       #
 16	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 17	
 18	int xw_readsort()
 19	{
 20	  FILE  *fp;
 21	  int   c;
 22	  int return_code = 0, linenum = 0;
 23	  BOOLEAN alpha_word, printable_clue;
 24	  register      int i;
 25	  register      WORDLIST        *ref, *new;
 26	  
 27	  fp = fopen(xw_inputfile, "r");
 28	  if (fp EQ NULL)
 29	    {
 30	      xw_error(SV_ERROR, "Error opening \"%s\"", xw_inputfile);
 31	    }
 32	  c = getc(fp);
 33	  while(c != EOF)
 34	    {
 35	      new = (WORDLIST *)xw_malloc(sizeof(WORDLIST));
 36	      i = 0;
 37	      new->wl_numchar = 0;
 38	      linenum++;
 39	      alpha_word = printable_clue = TRUE;
 40	      while(c != ' ' && c != '\n' && c != '\t' && c != EOF)
 41	        {
 42	          if(!isalpha(c))
 43	            {
 44	              alpha_word = FALSE;
 45	            }
 46	          c = islower(c) ? toupper(c) : c;
 47	#ifdef DEBUG
 48	          printf("readsort: word[%d] is  %c\n", i, c);


 8 Jul 22:52 2020 xw_readsort.c Page 2


 49	#endif /* DEBUG */
 50	          new->wl_word[i++] = c;
 51	          new->wl_numchar++;
 52	          xw_totletters++;
 53	          if (i > WORDLENGTH)
 54	            {
 55	              new->wl_word[i] = '\0';
 56	              xw_error(SV_INFO,"line %d: %s... too long for word (limit %d)",
 57	                       linenum,new->wl_word, WORDLENGTH);
 58	              return_code++;
 59	              while(c != ' ' && c != '\n' && c != '\t' && c != EOF)
 60	                {
 61	                  c = getc(fp);
 62	                }
 63	              break;
 64	            }
 65	          c = getc(fp);
 66	        }
 67	      new->wl_word[i] = '\0';
 68	      if(!alpha_word)
 69	        {
 70	          xw_error(SV_WARNING,"line %d: Words must be alphabetic(\"%s\")",
 71	                   linenum,new->wl_word);
 72	          return_code++;
 73	        }
 74	      if (i < 3)
 75	        {
 76	          xw_error(SV_INFO,"line %d: %s not long enough for word",linenum,new->wl_word);
 77	          return_code++;
 78	          /* break */;
 79	        }
 80	      xw_totwords++;
 81	
 82	/* Input the Clue. */
 83	      
 84	      i = 0;
 85	      if(c EQ ' ' || c EQ '\t')
 86	        {
 87	          c = getc(fp);
 88	        }
 89	      while((c != EOF) && (c != '\n'))
 90	        {
 91	          new->wl_clue[i++] = c;
 92	          if(!isprint(c) && c != '\t')
 93	            {
 94	              printable_clue = FALSE;
 95	            }
 96	          if(i > CLUELENGTH)


 8 Jul 22:52 2020 xw_readsort.c Page 3


 97	            {
 98	              if (CLUELENGTH > 30)
 99	                {
100	                  new->wl_clue[30] = '\0';
101	                }
102	              else
103	                {
104	                  new->wl_clue[i] = '\0';
105	                }
106	              xw_error(SV_INFO, "line %d: %30s... too long for clue (limit %d)",
107	                       linenum, new->wl_clue, CLUELENGTH);
108	              return_code++;
109	              while(c != '\n')
110	                {
111	                  c = getc(fp);
112	                }
113	              break;
114	            }
115	          c = getc(fp);
116	        }
117	      new->wl_clue[i] = '\0';
118	      if (!printable_clue)
119	        {
120	          xw_error(SV_WARNING,"line %d: Clues must be printable(\"%s\")",
121	                   linenum,new->wl_clue);
122	          return_code++;
123	        }
124	      if(i < 2)
125	        {
126	          xw_error(SV_INFO, "line %d: clue for %s not long enough for clue",linenum,new->wl_word);
127	          return_code++;
128	        }
129	      
130	      c = getc(fp);
131	#ifdef DEBUG
132	      printf("readsort: inserting  %s of length %d\n",
133	             new->wl_word, new->wl_numchar);
134	#endif /* DEBUG */
135	
136	/* Now, sort according to wordlength (ie. numchar field). */
137	                        
138	      ref = &xw_start;
139	      for(EVER)
140	        {
141	          if ((ref->wl_next EQ 0) || (ref->wl_next->wl_numchar < new->wl_numchar))
142	            {
143	#ifdef DEBUG
144	              printf("readsort: inserting after %s of length %d\n",


 8 Jul 22:52 2020 xw_readsort.c Page 4


145	                     ref->wl_word, ref->wl_numchar);
146	#endif /* DEBUG */
147	
148	/* Put it in. */
149	              new->wl_next = ref->wl_next;
150	              ref->wl_next = new;
151	              break;
152	            }
153	          else
154	            {
155	#ifdef DEBUG
156	              printf("readsort: moving past %s of length %d\n",
157	                     ref->wl_word, ref->wl_numchar);
158	#endif /* DEBUG */
159	
160	/* Move along */
161	
162	              ref = ref->wl_next;
163	            }
164	        }
165	    }
166	  if (xw_totwords > NUMWORDS)
167	        {
168	        xw_error(SV_INFO,
169	        "line %d: Word limit of %d exceeded; %d words encountered",
170	        linenum,NUMWORDS, xw_totwords);
171	        return_code++;
172	        }
173	  fclose(fp);
174	  return return_code;
175	}
176	
177	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
178	#               KILLIST                 #
179	#                                       #
180	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
181	
182	void xw_killlist()
183	{
184	  WORDLIST      *ref, *tmp;
185	
186	#ifdef DEBUG
187	  printf("killist: STARTING UP\n");
188	#endif /* DEBUG */
189	
190	  ref = xw_start.wl_next;
191	  while(ref != 0)
192	    {


 8 Jul 22:52 2020 xw_readsort.c Page 5


193	      tmp = ref->wl_next;
194	      TEST(PR(#018lx, (ULONG)ref));
195	      TEST(PRINT2(s, ref->wl_word, ref->wl_clue));
196	      free((char *)ref);
197	      ref = tmp;
198	    }
199	}
200	        
201	/* End of /home/franx/xword/xw_readsort.c */


21 Jul 19:39 2020 xw_sizedict.c Page 1


  1	/* /home/franxg/debianstuff/xword/xw_sizedict.c Wed06Jul2016 {fcG} */
  2	
  3	#include <ctype.h>
  4	#include <errno.h>
  5	#include <setjmp.h>
  6	#include <stdarg.h>
  7	#include <stdio.h>
  8	#include <stdlib.h>
  9	#include <string.h>
 10	#include <time.h>
 11	#include <unistd.h>
 12	/* #define extern */
 13	#include "xword.h"
 14	
 15	char sysbuf[SZ_STRING], buf[WORDLENGTH+1];
 16	
 17	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 18	#       SIZEDICT returns length of      #
 19	#       longest word in dictionary      #
 20	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 21	
 22	int xw_sizedict(char index[])
 23	{
 24	        UINT count;
 25	
 26	        count = 0;
 27	        for(EVER)
 28	        {
 29	#ifdef  DEBUG
 30	                PRINT2(#018lx, xw_indexfile, index);
 31	                PRINT2(s, xw_indexfile, index);
 32	#endif  /* DEBUG */
 33	
 34	/*              strncpy(xw_indexfile, index, sizeof(xw_indexfile)); */
 35	                INDEXDIR(++count);
 36	/*              sprintf(sysbuf, "[ -d  %s ]", xw_index); */
 37	                sprintf(sysbuf, "test -d  %s", xw_indexdir);
 38	
 39	// #ifdef       DEBUG
 40	                PR(s, sysbuf);
 41	                PRINT1(d, count);
 42	// #endif       /* DEBUG */
 43	                if (system(sysbuf) != 0)
 44	                {
 45	                        break;
 46	                }
 47	                else
 48	                {


21 Jul 19:39 2020 xw_sizedict.c Page 2


 49	#ifdef  DEBUG
 50	
 51	                        PR(s, sysbuf);
 52	                        PRINT1(d, count);
 53	#endif  /* DEBUG */
 54	                        ; // Do Nothing...
 55	
 56	
 57	                }
 58	        }
 59	        fprintf(stderr, "xw_sizedict: returning %d\n", count-1);
 60	        return count - 1;
 61	}
 62	
 63	#ifdef  SNARK
 64	int main(int argc, char *argv[])
 65	{
 66	        xw_sizedict("john.sort");
 67	}
 68	#endif  /* SNARK */
 69	        
 70	/* /End of /home/franxg/debianstuff/xword/xw_sizedict.c */


 8 Jul 21:56 2020 xw_tryword.c Page 1


  1	/* /home/franx/xword/xw_tryword.c Tue10Feb2004 {fcG} */
  2	
  3	// MODIFICATION HISTORY
  4	// When         Who     What
  5	// Wed08Jul2020 {fcG}   64-bit debug code.
  6	
  7	#include <stdio.h>
  8	#include "xword.h"
  9	
 10	BOOLEAN spotfound = FALSE;
 11	int     sizeincrease = UNDEFINED;
 12	/* WORDFIT      ret = { 0, 0, 0, UNUSED}; */
 13	
 14	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 15	#               XW_TRYWORD              #
 16	#                                       #
 17	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 18	
 19	void    xw_tryword(PUZZHEAD *ph, WORDLIST *w, int i, WORDLIST *x)
 20	{
 21	        int j;
 22	        int     newx, newy;
 23	        PUZZLE  *ref;
 24	
 25	#if DEBUG
 26	        printf("xw_tryword: w = %s, i = %d, x = %s[%s]\n",
 27	                w->wl_word, i, x->wl_word, DECODE(x->wl_status));
 28	#endif /* DEBUG */
 29	
 30	        if (x->wl_status != UNUSED)
 31	          {
 32	            for(j=0; j < x->wl_numchar; j++)
 33	              {
 34	                if(x->wl_word[j] EQ w->wl_word[i])
 35	                  {
 36	                    spotfound = TRUE;
 37	                    sizeincrease = UNDEFINED;
 38	                    if(x->wl_status EQ ACROSS)
 39	                      {
 40	                        ref = xw_pointpuzz(ph, x->wl_xpos + j, x->wl_ypos);
 41	                        newx = x->wl_xpos + j;
 42	                        newy = x->wl_ypos - i;
 43	                        xw_feelup(ph, w, i-1, ref->pz_up);
 44	                        if (spotfound)
 45	                          {
 46	                            xw_feeldown(ph, w, i+1, ref->pz_down);
 47	                          }
 48	                      }


 8 Jul 21:56 2020 xw_tryword.c Page 2


 49	                    else
 50	                      {
 51	                        ref = xw_pointpuzz(ph, x->wl_xpos, x->wl_ypos + j);
 52	                        newx = x->wl_xpos - i;   ;
 53	                        newy = x->wl_ypos + j;
 54	                        xw_feelleft(ph, w, i - 1, ref->pz_left);
 55	                        if (spotfound)
 56	                          {
 57	                            xw_feelright(ph, w, i + 1, ref->pz_right);
 58	                          }
 59	                      }
 60	                    if (spotfound && (sizeincrease < xw_ret.wf_size))
 61	                      {
 62	                        xw_ret.wf_size = sizeincrease;
 63	                        xw_ret.wf_x = newx;
 64	                        xw_ret.wf_y = newy;
 65	                        xw_ret.wf_status = INV(x->wl_status);
 66	                      }
 67	                  }
 68	              }
 69	          }
 70	        for(j = 0; x->wl_word[j] != w->wl_word[i]
 71	        && x->wl_word[j] != '\0'; j++)
 72	          {
 73	            ; /*  Do NOTHING!!! */
 74	          }
 75	        if (x->wl_sameletter[j] != w && x->wl_sameletter[j] != NULL)
 76	          {
 77	            xw_tryword(ph, w, i, x->wl_sameletter[j]);
 78	          }
 79	}
 80	
 81	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 82	#               XW_FEELUP               #
 83	#                                       #
 84	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 85	
 86	void    xw_feelup(PUZZHEAD *ph, WORDLIST *w, int i, PUZZLE *p)
 87	{
 88	#if DEBUG
 89	        printf("xw_feelup: w->word[i] = %c, i = %d, p = %#018lx\n",
 90	                w->wl_word[i], i, (ULONG)p);
 91	#endif /* DEBUG */
 92	
 93	        if (p EQ NULL)
 94	        {
 95	                sizeincrease = (i + 2) * (ph->ph_numcols - 2);
 96	        }


 8 Jul 21:56 2020 xw_tryword.c Page 3


 97	        else if (i < 0)
 98	        {
 99	          if ((p->pz_letter != EOWORD) && (p->pz_letter != '\0'))
100	            {
101	              spotfound = FALSE;
102	            }
103	          else
104	            {
105	              sizeincrease = 0;
106	            }
107	        }
108	        else if(p->pz_letter EQ EOWORD)
109	        {
110	                spotfound = FALSE;
111	        }
112	        else if(p->pz_letter EQ w->wl_word[i]
113	                || (p->pz_letter EQ '\0'
114	                    && (p->pz_left->pz_letter EQ '\0'
115	                        || p->pz_left->pz_letter EQ EOWORD)
116	                    && (p->pz_right->pz_letter EQ '\0'
117	                        || p->pz_right->pz_letter EQ EOWORD)))
118	        {
119	                xw_feelup(ph, w, i - 1, p->pz_up);
120	        }
121	        else
122	        {
123	                spotfound = FALSE;
124	        }
125	}
126	
127	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
128	#               XW_FEELDOWN             #
129	#                                       #
130	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
131	
132	void    xw_feeldown(PUZZHEAD *ph, WORDLIST *w, int i, PUZZLE *p)
133	{
134	#if DEBUG
135	        printf("xw_feeldown: w->word[i] = %c, i = %d, p = %#018lx\n",
136	                w->wl_word[i], i,  (ULONG)p);
137	#endif /* DEBUG */
138	
139	        if (p EQ NULL)
140	        {
141	          sizeincrease += (w->wl_numchar - i) * (ph->ph_numcols - 2);
142	        }
143	        else if (i >= w->wl_numchar)
144	          {


 8 Jul 21:56 2020 xw_tryword.c Page 4


145	            if ((p->pz_letter != EOWORD) && (p->pz_letter != '\0'))
146	              {
147	                spotfound = FALSE;
148	              }
149	          }
150	        else if (p->pz_letter EQ EOWORD)
151	          {
152	            spotfound = FALSE;
153	          }
154	        else if (p->pz_letter EQ w->wl_word[i]
155	                 || (p->pz_letter EQ '\0'
156	                     && (p->pz_left->pz_letter EQ '\0'
157	                         || p->pz_left->pz_letter EQ EOWORD)
158	                     && (p->pz_right->pz_letter EQ '\0'
159	                         || p->pz_right->pz_letter EQ EOWORD)))
160	          {
161	            xw_feeldown(ph, w, i + 1, p->pz_down);
162	          }
163	        else
164	          {
165	            spotfound = FALSE;
166	          }
167	}
168	
169	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
170	#               XW_FEELLEFT             #
171	#                                       #
172	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
173	
174	void    xw_feelleft(PUZZHEAD *ph, WORDLIST *w, int i, PUZZLE *p)
175	{
176	#if DEBUG
177	        printf("xw_feelleft: w->word[i] = %c, i = %d, p = %#018lx\n",
178	                w->wl_word[i], i,  (ULONG)p);
179	#endif /* DEBUG */
180	
181	        if (p EQ NULL)
182	          {
183	                sizeincrease = (i + 2) * (ph->ph_numrows - 2);
184	          }
185	        else if (i < 0)
186	          {
187	            if (p->pz_letter != '\0' && p->pz_letter != EOWORD)
188	              {
189	                spotfound = FALSE;
190	              }
191	            else
192	              {


 8 Jul 21:56 2020 xw_tryword.c Page 5


193	                sizeincrease = 0;
194	              }
195	          }
196	        else if (p->pz_letter EQ EOWORD)
197	          {
198	            spotfound = FALSE;
199	          }
200	        else if (p->pz_letter EQ w->wl_word[i]
201	                 || (p->pz_letter EQ '\0'
202	                     && (p->pz_up->pz_letter EQ '\0'
203	                         || p->pz_up->pz_letter EQ EOWORD)
204	                     && (p->pz_down->pz_letter EQ '\0'
205	                         || p->pz_down->pz_letter EQ EOWORD)))
206	        {
207	          xw_feelleft(ph, w, i - 1, p->pz_left);
208	        }
209	                 else
210	        {
211	          spotfound = FALSE;
212	        }
213	}
214	
215	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
216	#               XW_FEELRIGHT            #
217	#                                       #
218	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
219	
220	void    xw_feelright(PUZZHEAD *ph, WORDLIST *w, int i, PUZZLE *p)
221	{
222	#if DEBUG
223	        printf("xw_feelright: w->word[i] = %c, i = %d, p = %#018lx\n",
224	                w->wl_word[i], i,  (ULONG)p);
225	        PRINT1(d, w->wl_numchar);
226	#endif /* DEBUG */
227	
228	        if (p EQ NULL)
229	        {
230	                sizeincrease += (w->wl_numchar - i) * (ph->ph_numcols - 2);
231	        }
232	        else if (i >= w->wl_numchar)
233	        {
234	          if (p->pz_letter != '\0' && p->pz_letter != EOWORD)
235	            {
236	              spotfound = FALSE;
237	            }
238	        }
239	        else if (p->pz_letter EQ EOWORD)
240	          {


 8 Jul 21:56 2020 xw_tryword.c Page 6


241	            spotfound = FALSE;
242	          }
243	        else if (p->pz_letter EQ w->wl_word[i]
244	                 ||(p->pz_letter EQ '\0'
245	                    && (p->pz_up->pz_letter EQ '\0'
246	                        || p->pz_up->pz_letter EQ EOWORD)
247	                    && (p->pz_down->pz_letter EQ '\0'
248	                        || p->pz_down->pz_letter EQ EOWORD)))
249	        {
250	                xw_feelright(ph, w, i + 1, p->pz_right);
251	        }
252	        else
253	        {
254	                spotfound = FALSE;
255	        }
256	}
257	
258	/* End of /home/franx/xword/xw_tryword.c  */


22 Jul 22:07 2020 xw_fillpuzz.c Page 1


  1	/* /home/franx/xword/xw_fillpuzz.c Fri28Jul2006 {fcG} */
  2	//
  3	//  Created by Frank Charles Gallacher on 22/5/20.
  4	//  Copyleft © 2020 Frank Charles Gallacher. All rights reserved.
  5	//
  6	// MODIFICATION HISTORY
  7	// When         Who     What
  8	// Sat18Jul2020 {fcG}   xw_searchblanks() implemented...
  9	
 10	#include <ctype.h>
 11	#include <errno.h>
 12	#include <setjmp.h>
 13	#include <signal.h>
 14	#include <stdarg.h>
 15	#include <stdio.h>
 16	#include <stdlib.h>
 17	#include <string.h>
 18	#include <time.h>
 19	#include <unistd.h>
 20	//#define       extern
 21	#include "xword.h"
 22	
 23	typedef struct spot
 24	{
 25	  char sp_letter;
 26	  int  sp_pos;
 27	} SPOT;
 28	
 29	typedef struct wordhole
 30	{
 31	  int wh_key, wh_rownum, wh_colnum, wh_length, wh_spots;
 32	  STATUS wh_status;
 33	  struct wordhole *wh_next;
 34	  struct spot wh_spot[WORDLENGTH];
 35	 
 36	} WORDHOLE;
 37	
 38	WORDHOLE xw_whstart =
 39	  {
 40	    2020, UNDEFINED, UNDEFINED, 0, 0, UNUSED, NULL,
 41	  };
 42	
 43	char buf[SZ_FILENAME+1];
 44	
 45	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 46	#               xw_INSERTHOLE           #
 47	#                                       #
 48	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/


22 Jul 22:07 2020 xw_fillpuzz.c Page 2


 49	
 50	WORDHOLE *xw_inserthole(int spots, int letters, WORDHOLE *wh, PUZZLE *pzptr, STATUS stat) 
 51	{
 52	        register WORDHOLE *wh_ptr = &xw_whstart;
 53	
 54	        wh->wh_key = (spots * 100) + letters;
 55	        wh->wh_status = stat;
 56	        for(EVER)
 57	        {
 58	                if((wh_ptr->wh_next EQ NULL)
 59	                || (wh_ptr->wh_next->wh_key < wh->wh_key))
 60	                {
 61	                        wh->wh_next = wh_ptr->wh_next;
 62	                        wh_ptr->wh_next = wh;
 63	                        break;
 64	                }
 65	                else
 66	                {
 67	                        wh_ptr = wh_ptr->wh_next;
 68	                }
 69	        }
 70	        return (WORDHOLE *)xw_malloc(sizeof(WORDHOLE));
 71	}
 72	
 73	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 74	#               XW_SEARCHRANK           #
 75	#                                       #
 76	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 77	
 78	void xw_searchrank(PUZZLE *pzptr, STATUS stat, int length)
 79	{
 80	        register int i, numletters, numspots;
 81	        WORDHOLE *wh_ptr;
 82	
 83	        numletters = numspots = 0;
 84	        wh_ptr = (WORDHOLE *)xw_malloc(sizeof(WORDHOLE));
 85	        wh_ptr->wh_rownum = pzptr->pz_rownum;
 86	        wh_ptr->wh_colnum = pzptr->pz_colnum;
 87	
 88	  for(i = 0; i < length; i++)
 89	    {
 90	      if (pzptr->pz_letter EQ EOWORD)
 91	        {
 92	        if (numspots != 0 && numspots != numletters)
 93	        {
 94	                wh_ptr = xw_inserthole(numspots, numletters,
 95	                wh_ptr, pzptr, stat);
 96	                wh_ptr->wh_length = numletters;


22 Jul 22:07 2020 xw_fillpuzz.c Page 3


 97	                wh_ptr->wh_spots = numspots;
 98	        }
 99	        else
100	            {
101	              register int j;
102	              
103	/*            PRINT1(d, sizeof(SPOT)); */
104	/*            PRINT2(d, sizeof(wh_ptr->wh_spot), SZ_TABLE(wh_ptr->wh_spot)); */
105	
106	              for(j = 0; j < SZ_TABLE(wh_ptr->wh_spot); j++)
107	                {
108	                  wh_ptr->wh_spot[j].sp_letter = '\0';
109	                  wh_ptr->wh_spot[j].sp_pos = 0;
110	                }
111	            }
112	          if (stat EQ ACROSS)
113	            {
114	              wh_ptr->wh_rownum = pzptr->pz_rownum;
115	              wh_ptr->wh_colnum = pzptr->pz_colnum+1;
116	            }
117	          else
118	            {
119	              wh_ptr->wh_rownum = pzptr->pz_rownum+1;
120	              wh_ptr->wh_colnum = pzptr->pz_colnum;
121	            }
122	          numletters = numspots = 0;
123	        }
124	      else
125	        {
126	/*        TEST(PR(#06x,pzptr->pz_letter)); */
127	/*        TEST(PR(c,pzptr->pz_letter)); */
128	
129	          if (pzptr->pz_letter EQ '\0' || pzptr->pz_letter EQ ' ')
130	            {
131	              numletters++;
132	            }
133	          else
134	            {
135	              wh_ptr->wh_spot[numspots].sp_pos = ++numletters;
136	              wh_ptr->wh_spot[numspots++].sp_letter = pzptr->pz_letter;
137	
138	/*            TEST(PR(c,pzptr->pz_letter)); */
139	/*            TEST(PRINT2(d,numletters,numspots)); */
140	            }
141	        }
142	      if (stat EQ ACROSS)
143	        {
144	          pzptr = pzptr->pz_right;


22 Jul 22:07 2020 xw_fillpuzz.c Page 4


145	        }
146	      else
147	        {
148	          pzptr = pzptr->pz_down;
149	        }
150	    }
151	        if (numspots != 0 && numspots != numletters)
152	        {
153	                wh_ptr = xw_inserthole(numspots, numletters,
154	                        wh_ptr, pzptr, stat);
155	                wh_ptr->wh_length = numletters;
156	                wh_ptr->wh_spots = numspots;
157	        }
158	          else
159	        {
160	                free(wh_ptr);
161	        }
162	}
163	
164	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
165	#               XW_FINDGAPS             #
166	#                                       #
167	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
168	
169	void xw_findgaps(PUZZHEAD *ph)
170	{
171	  PUZZLE *hptr, *vptr;
172	  register int i;
173	
174	  hptr = ph->ph_puzzle;
175	  if(ph->ph_numrows != 1)
176	    {
177	      hptr = hptr->pz_down;
178	    }
179	  vptr = hptr->pz_right;
180	  for(i = 0; i < ph->ph_numcols - 2; i++)
181	  {
182	    xw_searchrank(vptr, DOWN, ph->ph_numrows-2);
183	    vptr = vptr->pz_right;
184	  }
185	  vptr = hptr->pz_right;
186	  for(i = 0; i < ph->ph_numrows - 2; i++)
187	  {
188	    xw_searchrank(vptr, ACROSS, ph->ph_numcols-2);
189	    vptr = vptr->pz_down;
190	  }
191	}       
192	


22 Jul 22:07 2020 xw_fillpuzz.c Page 5


193	
194	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
195	#       EQUIVALENCE_CHECK               #
196	#                                       #
197	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
198	
199	int equivalence_check(int length, long offset[])
200	{
201	        register int i,j,k;
202	        long min;
203	
204	        TEST(PRINT3(#06lx, offset[0], offset[1], offset[2]));
205	//      TEST(PRINT2(#018lx, offset[0], offset[1]));
206	
207	        min = MAXLONG;
208	        for(i = 0; i < length; i++)
209	        {
210	                if (offset[i] < min)
211	                {
212	                        min = offset[i];
213	                        k = i;
214	                }
215	        }
216	        j = 0;
217	        for(i = 0; i < length; i++)
218	        {
219	                if (offset[i] EQ min)
220	                {
221	                        j++;
222	                }
223	        }
224	        if (j EQ length)
225	        {
226	                return j;
227	        }
228	        else
229	        {
230	                return k;
231	        }
232	}
233	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
234	#       XW_SEARCH_BLANKS                #
235	#                                       #
236	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
237	
238	BOOLEAN xw_search_blanks(PUZZHEAD *ph)
239	{
240	        BOOLEAN search, equivalent;


22 Jul 22:07 2020 xw_fillpuzz.c Page 6


241	        FILE    *fp[WORDLENGTH], *minfp, *newfp;
242	        long    offset[WORDLENGTH],minoffset;
243	        int     count, max, min_count;
244	        register WORDHOLE *wh_ptr = &xw_whstart;
245	
246	        wh_ptr = &xw_whstart;
247	        wh_ptr = wh_ptr->wh_next;
248	        max = 0;
249	        if((max = xw_sizedict(xw_indexfile)) > WORDLENGTH)
250	        {
251	                xw_error(SV_FATAL,
252	                "Words in dictionary are too long... %d > %d\n",
253	                max, WORDLENGTH);
254	        }
255	        if(!max)        
256	        {
257	                xw_error(SV_FATAL, "Error in Dictionary %s\n",  
258	                        xw_indexfile);
259	        }
260	        WHERE; PRINT1(d, max);
261	        PRINT2(d, wh_ptr->wh_key, wh_ptr->wh_length);
262	        PRINT3(d, wh_ptr->wh_spots, wh_ptr->wh_rownum, wh_ptr->wh_colnum);
263	        for(count = 0; count < wh_ptr->wh_spots; count++)
264	        {
265	                INDEXDIR(wh_ptr->wh_spot[count].sp_pos);
266	                sprintf(buf, "%s/%c", xw_indexdir, 
267	                        wh_ptr->wh_spot[count].sp_letter);
268	                TEST(WHERE); TEST(PRINT1(s,buf));
269	                if (!(fp[count] = fopen(buf,"rb")))
270	                {
271	                        TEST(WHERE); xw_error(SV_FATAL,
272	                        "Error opening %s\n", buf);
273	                }
274	        }
275	        minoffset = MAXLONG;
276	        equivalent = FALSE;
277	        search = TRUE;
278	
279	        for(count = 0; count < wh_ptr->wh_spots; count++)
280	        {
281	                fread(&offset[count], sizeof(offset[count]), 1, fp[count]);
282	                if (ferror(fp[count]))
283	                {
284	                        INDEXDIR(wh_ptr->wh_spot[count].sp_pos);
285	                        sprintf(buf, "%s/%c", xw_indexdir, 
286	                                wh_ptr->wh_spot[count].sp_letter);
287	                        xw_error(SV_FATAL, "Error reading %s\n",
288	                                        buf);


22 Jul 22:07 2020 xw_fillpuzz.c Page 7


289	                }               
290	                if (feof(fp[count]))
291	                {
292	                        search = FALSE;
293	                        TEST(WHERE); TEST(fprintf(stderr, "Search failed!\n"));
294	                        break;
295	                }
296	        }
297	        if (wh_ptr->wh_spots < 2)
298	        {
299	                if (search)
300	                {
301	                        equivalent = TRUE;
302	                        min_count = 0;
303	                }
304	        }
305	
306	        if ((min_count = equivalence_check(wh_ptr->wh_spots, &offset))
307	        EQ wh_ptr->wh_spots)
308	        {
309	                equivalent = TRUE;
310	        }               
311	        TEST(WHERE); TEST(PRINT2(d, min_count, wh_ptr->wh_spots));
312	        while(!equivalent && search)
313	        {
314	
315	                fread(&offset[min_count], sizeof(offset[min_count]),
316	                        1, fp[min_count]);
317	                if (ferror(fp[min_count]))
318	                {
319	                        INDEXDIR(wh_ptr->wh_spot[min_count].sp_pos);
320	                        sprintf(buf, "%s/%c", xw_indexdir, 
321	                                wh_ptr->wh_spot[min_count].sp_letter);
322	                        xw_error(SV_FATAL, "Error reading %s\n",
323	                                        buf);
324	                }               
325	                if (feof(fp[min_count]))
326	                {
327	                        search = FALSE;
328	                        TEST(WHERE); TEST(PRINT1(d, min_count));
329	                        fprintf(stderr, "Search failed!\n");
330	                        break;
331	                }
332	                if ((min_count =
333	                equivalence_check(wh_ptr->wh_spots, &offset))
334	                EQ wh_ptr->wh_spots)
335	                {
336	                        equivalent = TRUE;


22 Jul 22:07 2020 xw_fillpuzz.c Page 8


337	                }
338	        }
339	        
340	        if (equivalent && search)
341	        {
342	                FILE *fp_dict;
343	
344	                if (!(fp_dict = fopen(xw_indexfile,"rb")))
345	                {
346	                        TEST(WHERE);xw_error(SV_ERROR, "index file open error/n");
347	                }
348	                TEST(WHERE); TEST(PRINT1(#018lx, offset[0]));
349	                if (fseek(fp_dict, offset[0], SEEK_SET) != 0)
350	                {
351	                        TEST(WHERE);xw_error(SV_ERROR, "fseek() error");
352	                }
353	                if(!fgets(buf, sizeof(buf), fp_dict))
354	                {
355	                        TEST(WHERE);xw_error(SV_ERROR, "fgets() error");
356	                }
357	                fprintf(stderr, "\"%s\"[%#018lx]==>%s",xw_indexfile,
358	                        offset[0],buf);
359	
360	                do
361	                {
362	                        for(count = 0; count < wh_ptr->wh_spots; count++)
363	                        {
364	                                fread(&offset[count],
365	                                sizeof(offset[count]), 1, fp[count]);
366	                                if (ferror(fp[count]))
367	                                {
368	                                        TEST(WHERE); INDEXDIR
369	                                        (wh_ptr->wh_spot[count].sp_pos);
370	
371	                                        sprintf(buf, "%s/%c", xw_indexdir, 
372	                                        wh_ptr->wh_spot[count].sp_letter);
373	                                        xw_error(SV_FATAL,
374	                                        "Error reading %s\n", buf);
375	                                }               
376	                                if (feof(fp[count]))
377	                                {
378	                                        search = FALSE;
379	                                        TEST(WHERE); TEST(fprintf(stderr,
380	                                        "Search failed!\n"));
381	                                        break;
382	                                }
383	                        }
384	                        if (equivalence_check(wh_ptr->wh_spots, &offset)


22 Jul 22:07 2020 xw_fillpuzz.c Page 9


385	                        EQ wh_ptr->wh_spots)
386	                        {
387	                                equivalent = TRUE;
388	                        }
389	                        else
390	                        {
391	                                equivalent = FALSE;
392	                                break;
393	                        }
394	
395	                        if (fseek(fp_dict, offset[0], SEEK_SET) != 0)
396	                        {
397	                                TEST(WHERE); xw_error(SV_ERROR, "fseek() error");
398	                        }
399	                        if(!fgets(buf, sizeof(buf), fp_dict))
400	                        {
401	                                TEST(WHERE); xw_error(SV_ERROR, "fgets() error");
402	                        }
403	                        fprintf(stderr, "\"%s\"[%#020lx]==>%s",xw_indexfile,
404	                                offset[0],buf);
405	                }       
406	                while (equivalent && search);
407	                if(fclose(fp_dict))
408	                {
409	                        TEST(WHERE); xw_error(SV_FATAL,"fclose() bombed!/n");
410	                }
411	        }       
412	        for(count = 0; count < wh_ptr->wh_spots; count++)
413	        {
414	                if(fclose(fp[count]))
415	                {
416	                        TEST(WHERE); xw_error(SV_FATAL, "fclose() bombed!/n");
417	                }
418	        }
419	        return equivalent;
420	}
421	
422	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
423	#               XW_FILLPUZZ             #
424	#                                       #
425	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
426	
427	PUZZHEAD *xw_fillpuzz(PUZZHEAD *ph)
428	{
429	  register WORDHOLE *wh_ptr = &xw_whstart;
430	  
431	  xw_findgaps(ph);
432	  


22 Jul 22:07 2020 xw_fillpuzz.c Page 10


433	#ifdef DEBUG
434	      wh_ptr =wh_ptr->wh_next;
435	
436	  WHEN; WHERE, nL;
437	  
438	  wh_ptr =wh_ptr->wh_next;
439	  while (wh_ptr != NULL)
440	    {
441	      register int i,j, k;
442	      
443	      printf("%d %s (%d,%d) ", wh_ptr->wh_key, DECODE(wh_ptr->wh_status),
444	             wh_ptr->wh_colnum,  wh_ptr->wh_rownum);
445	      for(i=0; i < wh_ptr->wh_key / 100; i++)
446	        {
447	          printf("\"%c\"[%#04x]->%d ", wh_ptr->wh_spot[i].sp_letter,
448	                 wh_ptr->wh_spot[i].sp_letter, wh_ptr->wh_spot[i].sp_pos);
449	        }
450	      for(j = k = 0; j < wh_ptr->wh_key % 100; j++)
451	        {
452	          if (wh_ptr->wh_spot[k].sp_pos - 1 EQ j)
453	            {
454	              buf[j] = wh_ptr->wh_spot[k++].sp_letter;
455	            }
456	          else
457	            {
458	                  buf[j] = '?';
459	            }
460	        }
461	        buf[j] = '\0';
462	        printf("%s\n", buf);
463	        
464	        wh_ptr->wh_spots = k;
465	        wh_ptr->wh_length = j;
466	        PRINT2(d, wh_ptr->wh_spots, wh_ptr->wh_length);
467	        wh_ptr = wh_ptr->wh_next;
468	    }
469	
470	#endif /* DEBUG */
471	
472	        xw_search_blanks(ph);
473	  return ph;
474	}       
475	
476	#ifdef  SNARK
477	main()
478	{
479	        BOOLEAN james;
480	        long    offset[WORDLENGTH],minoffset;


22 Jul 22:07 2020 xw_fillpuzz.c Page 11


481	        PUZZHEAD        puzzle_header;
482	        WORDHOLE testdata;
483	        register WORDHOLE *wh_ptr = &xw_whstart;
484	
485	        offset[0] = 4;
486	        offset[1] = 3;
487	        offset[2] = 2;
488	        offset[3] = 4;
489	        PRINT1(d, equivalence_check(4, &offset));
490	        
491	        offset[0] = 5;
492	        offset[1] = 5;
493	        offset[2] = 5;
494	        offset[3] = 5;
495	        PRINT1(d, equivalence_check(4, &offset));
496	        
497	        wh_ptr = &xw_whstart;
498	        wh_ptr->wh_next = &testdata;
499	        testdata.wh_key = 1010;
500	        testdata.wh_rownum = testdata.wh_colnum = 10;
501	        testdata.wh_status = ACROSS;
502	        testdata.wh_next = NULL;
503	        
504	        testdata.wh_spots = 3;
505	        testdata.wh_length = testdata.wh_colnum = 10;
506	        testdata.wh_status = ACROSS;
507	        testdata.wh_spot[0].sp_pos = 1;
508	        testdata.wh_spot[0].sp_letter = 'A';
509	        testdata.wh_spot[1].sp_pos = 2;
510	        testdata.wh_spot[1].sp_letter = 'C';
511	        testdata.wh_spot[2].sp_pos = 3;
512	        testdata.wh_spot[2].sp_letter = 'C';
513	
514	        strncpy(xw_indexfile, "john.sort", 16);
515	
516	        james = xw_search_blanks(&puzzle_header);
517	}
518	#endif  /* SNARK */ 
519	
520	/* End of /home/franx/xword/xw_fillpuzz.c */


 8 Jul 18:00 2020 xwindex.c Page 1


  1	/* /home/franx/xword/xwindex.c Fri21Jul2006 {fcG} */
  2	
  3	#include <ctype.h>
  4	#include <errno.h>
  5	#include <setjmp.h>
  6	#include <stdarg.h>
  7	#include <stdio.h>
  8	#include <stdlib.h>
  9	#include <string.h>
 10	#include <time.h>
 11	#include <unistd.h>
 12	#define extern
 13	#include "xword.h"
 14	
 15	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
 16	#               XWINDEX                 #
 17	# Create indexes from given dictionary  #
 18	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 19	
 20	int main(int argc, char *argv[])
 21	{
 22	  FILE  *fp;
 23	  BOOLEAN alpha_word, printable_clue;
 24	  int   c,i, linenum = 0, return_code = 0;
 25	  long offset;
 26	  char indexdir[SZ_FILENAME], sysbuf[SZ_STRING],
 27	        word[WORDLENGTH+1], clue[CLUELENGTH+1];
 28	
 29	  if(setjmp(xw_env) EQ 0)
 30	    {
 31	      printf(
 32	"\033[7m#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*#\033[0m\n");
 33	      printf(
 34	"\033[7m#                                     #\033[0m\n");
 35	      printf(
 36	"\033[7m#  Welcome to Franx X-word Indexer!   #\033[0m\n");
 37	      printf
 38	("\033[7m#                                     #\033[0m\n");
 39	      printf(
 40	"\033[7m#*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*#\033[0m\n");
 41	      WHEN;
 42	
 43	      if(argc < 2)
 44	        {
 45	          char buf[10];
 46	          
 47	          sprintf(buf, "%%%ds", SZ_FILENAME);
 48	          printf("\nInput file of dictonary words? ");


 8 Jul 18:00 2020 xwindex.c Page 2


 49	          scanf(buf, xw_indexfile);
 50	        }
 51	      else
 52	        {
 53	          PRINT1(s, argv[1]);
 54	          strncpy(xw_indexfile, argv[1], SZ_FILENAME);
 55	        }
 56	      
 57	      time(&xw_starttime);
 58	      system("date");
 59	      
 60	      fp = fopen(xw_indexfile, "r");
 61	      if (fp EQ NULL)
 62	        {
 63	          xw_error(SV_ERROR, "Error opening \"%s\"", xw_indexfile);
 64	        }
 65	
 66	      sprintf(xw_indexdir, "%s.index", xw_indexfile);
 67	
 68	      sprintf(sysbuf, "if [ -d  %s ]; then rm -rf %s; fi;",
 69	                xw_indexdir, xw_indexdir);
 70	      if (system(sysbuf))
 71	        {
 72	          xw_error(SV_ERROR, "Error nuking %s\n", xw_indexdir);
 73	        }
 74	      xw_error(SV_INFO, "XWINDEX: Nuked %s\n", xw_indexdir);
 75	
 76	      sprintf(sysbuf, "mkdir %s", xw_indexdir);
 77	      if (system(sysbuf))
 78	        {
 79	          xw_error(SV_ERROR, "Error recreating %s\n", xw_indexdir);
 80	        }
 81	
 82	      c = getc(fp);
 83	      offset = 0;
 84	      while(c != EOF)
 85	        {
 86	          FILE *newfp;
 87	          char newfname[SZ_FILENAME];
 88	
 89	          i = 0;
 90	          linenum++;
 91	          alpha_word = printable_clue = TRUE;
 92	          while(c != ' ' && c != '\n' && c != '\t' && c != EOF)
 93	            {
 94	              if(!isalpha(c))
 95	                {
 96	                  alpha_word = FALSE;


 8 Jul 18:00 2020 xwindex.c Page 3


 97	                }
 98	              c = islower(c) ? toupper(c) : c;
 99	              word[i++] = c;
100	              xw_totletters++;
101	              if (i > WORDLENGTH)
102	                {
103	                  word[i] = '\0';
104	                  xw_error(SV_INFO,
105	                        "line %d: %s... too long for word (limit %d)",
106	                        linenum, word, WORDLENGTH);
107	                  return_code++;
108	                  while(c != ' ' && c != '\n' && c != '\t' && c != EOF)
109	                    {
110	                      c = getc(fp);
111	                      i++;
112	                    }
113	                  break;
114	                }
115	              INDEXDIR(i);
116	              sprintf(sysbuf, "if [ ! -d  %s ]; then mkdir %s; fi;",
117	                      xw_indexdir, xw_indexdir);
118	              if (system(sysbuf))
119	                {
120	                  xw_error(SV_ERROR,
121	                        "Error creating %s/%c\n", xw_indexdir,c);
122	                }
123	
124	              sprintf(newfname, "%s/%c", xw_indexdir, c);
125	
126	              newfp = fopen(newfname, "ab");
127	              if (newfp EQ NULL)
128	                {
129	                  xw_error(SV_ERROR, "Error opening %s", newfname);
130	                };
131	              if (fwrite(&offset, sizeof(offset), 1, newfp) < 1)
132	                {
133	                  xw_error(SV_ERROR, "Error writing %s", newfname);
134	                }
135	              if (fclose(newfp) EQ EOF)
136	                {
137	                  xw_error(SV_ERROR, "Error closing %s", newfname);
138	                }
139	
140	              c = getc(fp);
141	            }
142	          word[i] = '\0';
143	          if(!alpha_word)
144	                {


 8 Jul 18:00 2020 xwindex.c Page 4


145	                xw_error(SV_WARNING,
146	                "line %d: Words must be alphabetic(\"%s\")",
147	                       linenum,word);
148	                return_code++;
149	                }
150	
151	          if (i < 3)
152	            {
153	              xw_error(SV_INFO,
154	                "line %d: %s not long enough for word",linenum,word);
155	              return_code++;
156	              /* break */;
157	            }
158	
159	          xw_totwords++;
160	        
161	          offset += i+1;
162	          i = 0;
163	          if(c EQ ' ' || c EQ '\t')
164	            {
165	              c = getc(fp);
166	              i++;
167	            }
168	          while((c != EOF) && (c != '\n'))
169	            {
170	              clue[i++] = c;
171	              if(!isprint(c) && c != '\t')
172	                {
173	                  printable_clue = FALSE;
174	                }
175	              if(i > CLUELENGTH)
176	                {
177	                  if (CLUELENGTH > 30)
178	                    {
179	                      clue[30] = '\0';
180	                    }
181	                  else
182	                    {
183	                      clue[i] = '\0';
184	                    }
185	#ifdef  SNARK
186	
187	                  xw_error(SV_INFO,
188	                        "line %d: %30s... too long for clue (limit %d)",
189	                           linenum, clue, CLUELENGTH);
190	                  return_code++;
191	#endif  /* SNARK */
192	


 8 Jul 18:00 2020 xwindex.c Page 5


193	                  while(c != '\n')
194	                    {
195	                      c = getc(fp);
196	                      i++;
197	                    }
198	                  break;
199	                }
200	              c = getc(fp);
201	            }
202	          clue[i] = '\0';
203	          if (!printable_clue)
204	            {
205	              xw_error(SV_WARNING,
206	                "line %d: Clues must be printable(\"%s\")",
207	                       linenum,clue);
208	              return_code++;
209	            }
210	
211	#ifdef  SNARK
212	          if(i < 2)
213	            {
214	              xw_error(SV_INFO,
215	                "line %d: clue for %s not long enough for clue",
216	                linenum,word);
217	              return_code++;
218	            }
219	#endif  /* SNARK */
220	          
221	          c = getc(fp);
222	          offset += i;
223	        }
224	      if (xw_totwords > NUMWORDS)
225	        {
226	                xw_error(SV_INFO,
227	                "line %d: Word limit of %d exceeded; %d words encountered",
228	                linenum,NUMWORDS, xw_totwords);
229	                return_code++;
230	        }
231	        fclose(fp);
232	        printf("Time elapsed %6.2f secs.\n",
233	        difftime(time(NULL), xw_starttime));      
234	        exit(0);
235	    }
236	  else
237	    {
238	      fprintf(stderr, "xwindex: aborting due to errors...\n");
239	      exit(-1);
240	    }


 8 Jul 18:00 2020 xwindex.c Page 6


241	}
242	        
243	/* End of /home/franx/xword/xwindex.c  */


 7 Jul 00:53 2020 version.c Page 1


  1	/* /Users/moonpie/xword/version.c Tue19May2020 {fcG} */
  2	
  3	/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*\
  4	#               VERSION                 #
  5	#     date compiled/version slave       #
  6	\*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
  7	
  8	/* #include "defs.h" */
  9	#include "version.h"
 10	
 11	char *date_compiled()
 12	{
 13	        static char datecomp[] = DATE_COMPILED;
 14	        return datecomp;
 15	}
 16	
 17	float version()
 18	{
 19	        static float    ver = _VERSION_;
 20	        return ver;
 21	}
 22	
 23	/* End of /Users/moonpie/xword/version.c  */
